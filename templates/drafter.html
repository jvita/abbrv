{% extends "index.html" %}

{% block content %}
<div class="app2-container">
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Draft</title>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap">
        <link rel="stylesheet" href="{{ url_for('static', filename='drafter_styles.css') }}">
    </head>
    <body>
        <!-- <h1>Draft</h1> -->
        <div class="container">
            <div class="main-content">
                <div class="controls">
                    <h2>Character</h2>
                    <input type="text" id="character" placeholder="Enter character(s)">
                    <div class="button-container">
                        <button id="saveButton">Save</button>
                        <button id="clearButton">Clear Points</button>
                    </div>
                    <h2>Saved Splines</h2>
                    <div id="splineList" class="spline-list"></div>
                    <div class="button-container">
                        <button id="freezeButton" class="freeze-button" style="display:none;">Freeze</button>
                        <button id="deleteButton" class="delete-button" style="display:none;">Delete</button>
                    </div>
                </div>
                <div class="grid-container">
                    <canvas id="splineCanvas" width="1240" height="1240"></canvas>
                    <canvas id="gridCanvas" width="1240" height="1240"></canvas>
                </div>
            </div>
        </div>
        <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
        <script>
            let splineData = {}; // Global variable to store spline data
            const gridCanvas = document.getElementById('gridCanvas');
            const gridCtx = gridCanvas.getContext('2d');
            const splineCanvas = document.getElementById('splineCanvas');
            const splineCtx = splineCanvas.getContext('2d');
            const characterField = document.getElementById('character');
            const saveButton = document.getElementById('saveButton');
            const clearButton = document.getElementById('clearButton');
            const deleteButton = document.getElementById('deleteButton');
            const freezeButton = document.getElementById('freezeButton');
            const splineList = document.getElementById('splineList');

            let frozenPoints = [];
            let selectedPoints = [];
            let selectedCharacter = null;
            let frozenCharacter = null; // Track the currently frozen spline
            const gridSize = 62;
            const cellSize = 20;
            const centerOffset = Math.floor(gridSize / 2) * cellSize;

            function drawGrid() {
                gridCtx.clearRect(0, 0, gridCanvas.width, gridCanvas.height);

                // Draw the lighter grid lines
                gridCtx.beginPath();
                gridCtx.strokeStyle = 'rgba(0, 0, 0, 0.1)'; // Very light gray
                gridCtx.lineWidth = 1; // Thin line width
                for (let i = 0; i <= gridSize; i++) {
                    gridCtx.moveTo(i * cellSize, 0);
                    gridCtx.lineTo(i * cellSize, gridCanvas.height);
                    gridCtx.moveTo(0, i * cellSize);
                    gridCtx.lineTo(gridCanvas.width, i * cellSize);
                }
                gridCtx.stroke();

                // Draw the darker center lines
                gridCtx.beginPath();
                gridCtx.strokeStyle = '#000'; // Dark color for center lines
                gridCtx.lineWidth = 1; // Thinner line width for center lines
                const centerX = centerOffset;
                const centerY = centerOffset;

                // Vertical center line
                gridCtx.moveTo(centerX, 0);
                gridCtx.lineTo(centerX, gridCanvas.height);

                // Horizontal center line
                gridCtx.moveTo(0, centerY);
                gridCtx.lineTo(gridCanvas.width, centerY);

                gridCtx.stroke();

                // Draw the dark center squares
                gridCtx.beginPath();
                gridCtx.strokeStyle = '#000';
                gridCtx.lineWidth = 1;
                gridCtx.strokeRect(centerX - 120, centerY - 120, 240, 240);
                gridCtx.strokeRect(centerX - 240, centerY - 240, 480, 480);
                gridCtx.strokeRect(centerX - 360, centerY - 360, 720, 720);
                gridCtx.strokeRect(centerX - 480, centerY - 480, 960, 960);
                gridCtx.strokeRect(centerX - 600, centerY - 600, 1200, 1200);
                gridCtx.stroke();
            }

            function drawPoints() {
                gridCtx.clearRect(0, 0, gridCanvas.width, gridCanvas.height); // Clear the grid canvas before redrawing
                drawGrid(); // Redraw the grid
                gridCtx.fillStyle = 'red'; // Color for knot points
                selectedPoints.forEach(([x, y]) => {
                    gridCtx.beginPath();
                    gridCtx.arc(centerOffset + x * cellSize, centerOffset - y * cellSize, 5, 0, Math.PI * 2);
                    gridCtx.fill();
                });
            }

            function updatePointsField() {
                splineCtx.clearRect(0, 0, splineCanvas.width, splineCanvas.height); // Clear spline visualization

                drawPoints(); // Draw new points

                const normalizedPointsFrozen = frozenPoints.map(([x, y]) => [(x + gridSize / 2) / gridSize, (y + gridSize / 2) / gridSize]);
                plotSpline(normalizedPointsFrozen, true);

                const normalizedPointsSelected = selectedPoints.map(([x, y]) => [(x + gridSize / 2) / gridSize, (y + gridSize / 2) / gridSize]);
                plotSpline(normalizedPointsSelected, false);

            }

            function plotSpline(points, isFrozen = false) {
                if (points.length < 2) {
                    splineCtx.clearRect(0, 0, splineCanvas.width, splineCanvas.height);
                    return;
                }

                axios.post('/spline', { points })
                    .then(response => {
                        splineCtx.beginPath();
                        splineCtx.lineWidth = 2; // Thicker line width for spline
                        splineCtx.strokeStyle = isFrozen ? 'gray' : 'blue'; // Use gray for frozen spline
                        const spline = response.data.spline;
                        spline.forEach(([x, y], index) => {
                            const plotX = (x + (gridSize / 2)) * (splineCanvas.width / gridSize);
                            const plotY = splineCanvas.height - ((y + (gridSize / 2)) * (splineCanvas.height / gridSize));
                            if (index === 0) {
                                splineCtx.moveTo(plotX, plotY);
                            } else {
                                splineCtx.lineTo(plotX, plotY);
                            }
                        });
                        splineCtx.stroke();
                    });
            }

            gridCanvas.addEventListener('click', (event) => {
                if (frozenCharacter) return; // Prevent point selection if a spline is frozen

                const rect = gridCanvas.getBoundingClientRect();
                const x = event.clientX - rect.left - centerOffset;
                const y = rect.top + centerOffset - event.clientY;
                const gridX = Math.round(x / cellSize);
                const gridY = Math.round(y / cellSize);

                // Check if Ctrl key is pressed
                const isCtrlPressed = event.ctrlKey;

                // Find if the point is already selected
                const pointIndex = selectedPoints.findLastIndex(([px, py]) => px === gridX && py === gridY);

                if (isCtrlPressed) {
                    // Ctrl+click: Remove the point if it exists
                    if (pointIndex !== -1) {
                        selectedPoints.splice(pointIndex, 1);
                    }
                } else {
                    // Regular click: Add the point if it's not already selected
                    if (pointIndex === -1) {
                        selectedPoints.push([gridX, gridY]);
                    }
                }

                updatePointsField();
            });

            saveButton.addEventListener('click', () => {
                const character = characterField.value.trim();
                if (character && selectedPoints.length) {
                    const data = {
                        character: character,
                        points: selectedPoints.map(([x, y]) => [(x + gridSize / 2) / gridSize, (y + gridSize / 2) / gridSize])
                    };
                    axios.post('/save', data)
                        .then(response => {
                            if (response.data.status === 'success') {
                                loadSplines();
                                characterField.value = '';
                                selectedPoints = [];
                                updatePointsField();
                            }
                        });
                }
            });

            clearButton.addEventListener('click', () => {
                selectedPoints = [];
                updatePointsField();
            });

            deleteButton.addEventListener('click', () => {
                if (selectedCharacter) {
                    axios.post('/delete', { character: selectedCharacter })
                        .then(response => {
                            if (response.data.status === 'success') {
                                loadSplines();
                                characterField.value = '';
                                selectedPoints = [];
                                updatePointsField();
                                deleteButton.style.display = 'none'; // Hide delete button after deleting
                                freezeButton.style.display = 'none'; // Hide freeze button after deleting
                                if (frozenCharacter === selectedCharacter) {
                                    frozenCharacter = null; // Unfreeze if the deleted spline was frozen
                                    freezeButton.textContent = 'Freeze';
                                }
                            }
                        });
                }
            });

            function loadSplines() {
                axios.get('/load')
                    .then(response => {

                        splineData = response.data; // Store the data in the global variable
                        splineList.innerHTML = '';
                        deleteButton.style.display = 'none'; // Hide delete button initially

                        splineCtx.clearRect(0, 0, splineCanvas.width, splineCanvas.height);

                        for (const [character, points] of Object.entries(splineData)) {
                            const listItem = document.createElement('div');
                            listItem.className = 'spline-item';
                            listItem.textContent = character;

                            listItem.addEventListener('click', () => {
                                if ((selectedCharacter === character) || (frozenCharacter === character)){
                                    if (frozenCharacter !== character) {
                                        // Deselect the spline
                                        selectedPoints = [];
                                        selectedCharacter = null;
                                        characterField.value = ''; // Clear the character field
                                        deleteButton.style.display = 'none'; // Hide delete button
                                        // freezeButton.style.display = 'none'; // Hide freeze button
                                        if (frozenCharacter === character) {
                                            frozenCharacter = null; // Unfreeze if this was the frozen spline
                                            freezeButton.textContent = 'Freeze';
                                        }

                                        // Remove the selected class from the clicked item
                                        listItem.classList.remove('selected');
                                    }
                                } else {
                                    // Remove selected class from all items
                                    document.querySelectorAll('.spline-item').forEach(item => {
                                        item.classList.remove('selected');
                                    });

                                    selectedPoints = points.map(([x, y]) => [x * gridSize - gridSize / 2, y * gridSize - gridSize / 2]);
                                    characterField.value = character;
                                    selectedCharacter = character;
                                    deleteButton.style.display = 'inline-block'; // Show delete button
                                    freezeButton.style.display = frozenCharacter || selectedCharacter ? 'inline-block' : 'none'; // Show freeze button if spline is selected or frozen

                                    // Add selected class to the clicked item
                                    listItem.classList.add('selected');

                                    // Check if this spline is the currently frozen one
                                    if (frozenCharacter === character) {
                                        freezeButton.textContent = 'Unfreeze';
                                    }
                                }

                                updatePointsField();

                            });

                            // Make sure selected character is always highlighted
                            if (character === selectedCharacter) {
                                listItem.classList.add('selected');
                            }

                            // Apply frozen class if this spline is frozen
                            if (frozenCharacter === character) {
                                listItem.classList.add('frozen');
                                listItem.classList.remove('selected');

                                // Record frozen points for plotting spline later
                                frozenPoints = points.map(([x, y]) => [x * gridSize - gridSize / 2, y * gridSize - gridSize / 2]);
                            }

                            splineList.appendChild(listItem);
                        }

                        // Update freeze button visibility after loading splines
                        freezeButton.style.display = frozenCharacter || selectedCharacter ? 'inline-block' : 'none';

                        updatePointsField();
                    });
            }

            freezeButton.addEventListener('click', () => {
                if (frozenCharacter) {
                    // Unfreeze the currently frozen spline
                    frozenPoints = []
                    frozenCharacter = null;
                    freezeButton.textContent = 'Freeze';
                } else {
                    if (selectedCharacter) {
                        // Freeze the currently selected spline
                        frozenCharacter = selectedCharacter;
                        freezeButton.textContent = 'Unfreeze';

                        // Unselect it now that it's been frozen
                        selectedPoints = [];
                        selectedCharacter = null;
                        characterField.value = ''; // Clear the character field
                        deleteButton.style.display = 'none'; // Hide delete button
                    }
                }
                
                // Reload splines to apply the frozen class
                loadSplines(); 
            });

            drawGrid();
            loadSplines();

            document.addEventListener("DOMContentLoaded", function() {
                const gridContainer = document.querySelector('.grid-container');
                const containerWidth = gridContainer.clientWidth;
                const containerHeight = gridContainer.clientHeight;
                const gridWidth = 1240;
                const gridHeight = 1240;

                gridContainer.scrollLeft = (gridWidth - containerWidth) / 2;
                gridContainer.scrollTop = (gridHeight - containerHeight) / 2;
            });
        </script>
    </body>
    </html>
</div>
{% endblock %}
