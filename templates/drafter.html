{% extends "index.html" %}

{% block content %}
<div class="app2-container">
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Draft</title>
        <!-- <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap"> -->
        <!-- <link rel="stylesheet" href="{{ url_for('static', filename='drafter_styles.css') }}"> -->
    </head>
    <body>
        <div class="container">
            <div class="main-content">
                <div class="controls">
                    <h2>Editing character</h2>
                    <input type="text" id="character" placeholder="Enter character(s)" autocomplete="off">
                    <!-- <h2>Saved splines</h2> -->
                    <div class="d-flex flex-row">
                        <div class="d-flex flex-column flex-grow-1">
                            <h2>Characters</h2>
                            <div id="charactersList" class="spline-list" style="margin-right: 5px;"></div>
                        </div>
                        <div class="d-flex flex-column flex-grow-1">
                            <h2 style="margin-left: 5px">Joins</h2>
                            <div id="joinsList" class="spline-list" style="margin-left: 5px;"></div>
                        </div>
                    </div>
                    <div class="d-flex flex-row justify-content-between">
                        <div>
                            <button id="saveButton">Save</button>
                            <button id="clearButton">Clear</button>
                            <button id="joinButton" class="join-button" style="display:none;">Join</button>
                            <button id="deleteButton" class="delete-button" style="display:none;">Delete</button>
                        </div>
                    </div>
                </div>
                <div class="grid-container">
                    <canvas id="splineCanvas" width="1440" height="1440"></canvas>
                    <canvas id="gridCanvas" width="1440" height="1440"></canvas>
                </div>
            </div>
        </div>
        <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
        <script>
            let charSplineData = {}; // Global variable to store spline data
            let joinsSplineData = {}; // Global variable to store spline data
            const gridCanvas = document.getElementById('gridCanvas');
            const gridCtx = gridCanvas.getContext('2d');
            const splineCanvas = document.getElementById('splineCanvas');
            const splineCtx = splineCanvas.getContext('2d');
            const characterField = document.getElementById('character');
            const saveButton = document.getElementById('saveButton');
            const clearButton = document.getElementById('clearButton');
            const deleteButton = document.getElementById('deleteButton');
            const joinButton = document.getElementById('joinButton');
            const charactersList = document.getElementById('charactersList');
            const joinsList = document.getElementById('joinsList');

            let joiningPoints = [];
            let selectedPoints = [];
            let selectedCharacter = null;
            let joiningCharacter = null; // Track the currently joining spline
            const gridSize = 72;
            const cellSize = 20;
            const centerOffset = Math.floor(gridSize / 2) * cellSize;

            function drawGrid() {
                gridCtx.clearRect(0, 0, gridCanvas.width, gridCanvas.height);

                // Draw the lighter grid lines
                gridCtx.beginPath();
                gridCtx.strokeStyle = 'rgba(0, 0, 0, 0.1)'; // Very light gray
                gridCtx.lineWidth = 1; // Thin line width
                for (let i = 0; i <= gridSize; i++) {
                    gridCtx.moveTo(i * cellSize, 0);
                    gridCtx.lineTo(i * cellSize, gridCanvas.height);
                    gridCtx.moveTo(0, i * cellSize);
                    gridCtx.lineTo(gridCanvas.width, i * cellSize);
                }
                gridCtx.stroke();

                // Draw the darker center lines
                gridCtx.beginPath();
                gridCtx.strokeStyle = '#000'; // Dark color for center lines
                gridCtx.lineWidth = 1; // Thinner line width for center lines
                const centerX = centerOffset;
                const centerY = centerOffset;

                // Vertical center line
                gridCtx.moveTo(centerX, 0);
                gridCtx.lineTo(centerX, gridCanvas.height);

                // Horizontal center line
                gridCtx.moveTo(0, centerY);
                gridCtx.lineTo(gridCanvas.width, centerY);

                gridCtx.stroke();

                // Draw the dark center squares
                gridCtx.beginPath();
                gridCtx.strokeStyle = '#000';
                gridCtx.lineWidth = 1;
                gridCtx.strokeRect(centerX - 120, centerY - 120, 240, 240);
                gridCtx.strokeRect(centerX - 240, centerY - 240, 480, 480);
                gridCtx.strokeRect(centerX - 360, centerY - 360, 720, 720);
                gridCtx.strokeRect(centerX - 480, centerY - 480, 960, 960);
                gridCtx.strokeRect(centerX - 600, centerY - 600, 1200, 1200);
                gridCtx.stroke();
            }

            function drawPoints() {
                gridCtx.clearRect(0, 0, gridCanvas.width, gridCanvas.height); // Clear the grid canvas before redrawing
                drawGrid(); // Redraw the grid
                gridCtx.fillStyle = 'red'; // Color for knot points
                selectedPoints.forEach(([x, y]) => {
                    gridCtx.beginPath();
                    gridCtx.arc(centerOffset + x * cellSize, centerOffset - y * cellSize, 5, 0, Math.PI * 2);
                    gridCtx.fill();
                });
            }

            function updatePointsField() {
                splineCtx.clearRect(0, 0, splineCanvas.width, splineCanvas.height); // Clear spline visualization

                drawPoints(); // Draw new points

                // Calculate the shift required to align the joining char to the selected char
                if (joiningPoints.length > 0) {
                    let lastX = 0;
                    let lastY = 0;

                    if (selectedPoints.length > 0) {
                        [lastX, lastY] = selectedPoints[0];
                    }

                    const [firstX, firstY] = joiningPoints[joiningPoints.length - 1]
                    const shiftedJoinPoints = joiningPoints.map(([x, y]) => [x - firstX + lastX, y - firstY + lastY]);
                    const normalizedPointsJoining = shiftedJoinPoints.map(([x, y]) => [(x + gridSize / 2) / gridSize, (y + gridSize / 2) / gridSize]);
                    plotSpline(normalizedPointsJoining, true);
                }

                const normalizedPointsSelected = selectedPoints.map(([x, y]) => [(x + gridSize / 2) / gridSize, (y + gridSize / 2) / gridSize]);
                plotSpline(normalizedPointsSelected, false);
            }

            function plotSpline(points, isJoining = false) {
                if (points.length < 2) {
                    splineCtx.clearRect(0, 0, splineCanvas.width, splineCanvas.height);
                    return;
                }

                axios.post('/spline', { points })
                    .then(response => {
                        splineCtx.beginPath();
                        splineCtx.lineWidth = 2; // Thicker line width for spline
                        splineCtx.strokeStyle = isJoining ? 'red' : 'blue';
                        const spline = response.data.spline;
                        spline.forEach(([x, y], index) => {
                            const plotX = (x + (gridSize / 2)) * (splineCanvas.width / gridSize);
                            const plotY = splineCanvas.height - ((y + (gridSize / 2)) * (splineCanvas.height / gridSize));
                            if (index === 0) {
                                splineCtx.moveTo(plotX, plotY);
                            } else {
                                splineCtx.lineTo(plotX, plotY);
                            }
                        });
                        splineCtx.stroke();
                    });
            }

            gridCanvas.addEventListener('click', (event) => {
                // if (joiningCharacter) return; // Prevent point selection if a spline is joining

                const rect = gridCanvas.getBoundingClientRect();
                const x = event.clientX - rect.left - centerOffset;
                const y = rect.top + centerOffset - event.clientY;
                const gridX = Math.round(x / cellSize);
                const gridY = Math.round(y / cellSize);

                // Check if Ctrl key is pressed
                const isCtrlPressed = event.ctrlKey;

                // Find if the point is already selected
                const pointIndex = selectedPoints.findLastIndex(([px, py]) => Math.round(px) === gridX && Math.round(py) === gridY);

                if (isCtrlPressed) {
                    // Ctrl+click: Remove the point if it exists
                    if (pointIndex !== -1) {
                        selectedPoints.splice(pointIndex, 1);
                    }
                } else {
                    // Regular click: Add the point if it's not already selected
                    if (pointIndex === -1) {
                        selectedPoints.push([gridX, gridY]);
                    }
                }

                updatePointsField();
            });

            saveButton.addEventListener('click', () => {
                const character = characterField.value.trim();
                if (character && selectedPoints.length) {
                    const data = {
                        character: character,
                        joinchar: joiningCharacter,
                        points: selectedPoints.map(([x, y]) => [(x + gridSize / 2) / gridSize, (y + gridSize / 2) / gridSize]),
                    };
                    axios.post('/save', data)
                        .then(response => {
                            if (response.data.status === 'success') {
                                loadJoins();
                                loadCharacters();
                                characterField.value = '';
                                selectedPoints = [];
                                updatePointsField();
                            }
                        });
                }
            });

            clearButton.addEventListener('click', () => {
                selectedPoints = [];
                updatePointsField();
            });

            deleteButton.addEventListener('click', () => {
                console.log("Delete clicked")
                if (selectedCharacter) {
                    axios.post('/delete', { character: selectedCharacter , joinchar: joiningCharacter})
                        .then(response => {
                            if (response.data.status === 'success') {
                                loadJoins();
                                loadCharacters();
                                characterField.value = '';
                                selectedPoints = [];
                                updatePointsField();
                                deleteButton.style.display = 'none'; // Hide delete button after deleting
                                joinButton.style.display = 'none'; // Hide join button after deleting
                                if (joiningCharacter === selectedCharacter) {
                                    joiningCharacter = null; // Stop joining if spline was deleted
                                    joinButton.textContent = 'Join';
                                }
                            }
                        });
                }
            });

            function loadCharacters() {
                axios.get('/load_characters')
                    .then(response => {

                        charSplineData = response.data; // Store the data in the global variable
                        charactersList.innerHTML = '';
                        deleteButton.style.display = 'none'; // Hide delete button initially

                        splineCtx.clearRect(0, 0, splineCanvas.width, splineCanvas.height);

                        for (const [character, points] of Object.entries(charSplineData)) {
                            const listItem = document.createElement('div');
                            listItem.className = 'spline-item';
                            listItem.textContent = character;

                            listItem.addEventListener('click', () => {
                                if ((selectedCharacter === character) || (joiningCharacter === character)){
                                    if (joiningCharacter !== character) {
                                        // Deselect the spline
                                        selectedPoints = [];
                                        selectedCharacter = null;
                                        characterField.value = ''; // Clear the character field
                                        deleteButton.style.display = 'none'; // Hide delete button
                                        if (!joiningCharacter) {
                                            joinButton.style.display = 'none';
                                        }
                                        if (joiningCharacter === character) {
                                            joiningCharacter = null;
                                        }

                                        // Remove the selected class from the clicked item
                                        listItem.classList.remove('selected');
                                    }
                                } else {
                                    // Remove selected class from all items
                                    document.querySelectorAll('.spline-item').forEach(item => {
                                        item.classList.remove('selected');
                                    });

                                    selectedPoints = points.map(([x, y]) => [x * gridSize - gridSize / 2, y * gridSize - gridSize / 2]);
                                    characterField.value = character;
                                    selectedCharacter = character;
                                    deleteButton.style.display = 'inline-block'; // Show delete button
                                    joinButton.style.display = joiningCharacter || selectedCharacter ? 'inline-block' : 'none'; // Show jion button if spline is selected or joining

                                    // Add selected class to the clicked item
                                    listItem.classList.add('selected');

                                    // Check if this spline is the currently joining one
                                    if (joiningCharacter === character) {
                                        joinButton.textContent = 'Unjoin';
                                    }
                                }

                                updatePointsField();

                            });

                            // Make sure selected character is always highlighted
                            if (character === selectedCharacter) {
                                listItem.classList.add('selected');
                            }

                            // Apply join class if this spline is joining
                            if (joiningCharacter === character) {
                                listItem.classList.add('joining');
                                listItem.classList.remove('selected');

                                // Record joining points for plotting spline later
                                joiningPoints = points.map(([x, y]) => [x * gridSize - gridSize / 2, y * gridSize - gridSize / 2]);
                            }

                            charactersList.appendChild(listItem);
                        }

                        // Update join button visibility after loading splines
                        joinButton.style.display = joiningCharacter || selectedCharacter ? 'inline-block' : 'none';
                        deleteButton.style.display = joiningCharacter || selectedCharacter ? 'inline-block' : 'none';

                        updatePointsField();
                    });
            }

            function loadJoins() {
                axios.get('/load_joins')
                    .then(response => {

                        charSplineData = response.data['chars'];
                        joinsSplineData = response.data['joins'];
                        joinsList.innerHTML = '';
                        deleteButton.style.display = 'none'; // Hide delete button initially
                        joinButton.style.display = 'none'; // Hide delete button initially

                        splineCtx.clearRect(0, 0, splineCanvas.width, splineCanvas.height);

                        for (const [character, charPoints] of Object.entries(charSplineData)) {
                            if (!(character in joinsSplineData)) {
                                continue
                            }

                            for (const [joinchar, joinPoints] of Object.entries(joinsSplineData[character])) {
                                const listItem = document.createElement('div');
                                listItem.className = 'spline-item';
                                listItem.textContent = joinchar+character;
                                listItem.addEventListener('click', () => {
                                    if ((selectedCharacter === joinchar) || (joiningCharacter === joinchar)){
                                        if (joiningCharacter !== joinchar) {
                                            // Deselect the spline
                                            selectedPoints = [];
                                            selectedCharacter = null;
                                            characterField.value = ''; // Clear the character field
                                            // deleteButton.style.display = 'none'; // Hide delete button

                                            // Remove the selected class from the clicked item
                                            listItem.classList.remove('selected');
                                        }
                                    } else {
                                        // Remove selected class from all items
                                        document.querySelectorAll('.spline-item').forEach(item => {
                                            item.classList.remove('selected');
                                        });

                                        selectedPoints = joinPoints.map(([x, y]) => [x * gridSize - gridSize / 2, y * gridSize - gridSize / 2]);
                                        characterField.value = joinchar;
                                        selectedCharacter = character;
                                        characterField.value = character;
                                        // deleteButton.style.display = 'inline-block'; // Show delete button

                                        // Add selected class to the clicked item
                                        // listItem.classList.add('selected');
                                    }

                                    joiningPoints = charSplineData[joinchar].map(([x, y]) => [x * gridSize - gridSize / 2, y * gridSize - gridSize / 2]);
                                    joiningCharacter = joinchar
                                    joinButton.style.display = 'inline-block';
                                    joinButton.textContent = 'Unjoin';
                                    updatePointsField();
                                    loadCharacters();
                                });

                                // Make sure selected character is always highlighted
                                if (joinchar === selectedCharacter) {
                                    listItem.classList.add('selected');
                                }
                                joinsList.appendChild(listItem);
                            }
                        }
                        updatePointsField();
                    });
            }

            joinButton.addEventListener('click', () => {
                if (joiningCharacter) {
                    // Unjoin the currently joining spline
                    joiningPoints = []
                    joiningCharacter = null;
                    joinButton.textContent = 'Join';
                } else {
                    if (selectedCharacter) {
                        // Join the currently selected spline
                        joinButton.style.display = 'none'; // Hide delete button
                        joiningCharacter = selectedCharacter;
                        joinButton.textContent = 'Unjoin';

                        // Unselect it now that it's been joined
                        selectedPoints = [];
                        selectedCharacter = null;
                        characterField.value = ''; // Clear the character field
                        deleteButton.style.display = 'none'; // Hide delete button
                    }
                }

                loadCharacters();
            });

            drawGrid();
            loadJoins();
            loadCharacters();

            document.addEventListener("DOMContentLoaded", function() {
                const gridContainer = document.querySelector('.grid-container');
                const containerWidth = gridContainer.clientWidth;
                const containerHeight = gridContainer.clientHeight;
                const gridWidth = 1440;
                const gridHeight = 1440;

                gridContainer.scrollLeft = (gridWidth - containerWidth) / 2;
                gridContainer.scrollTop = (gridHeight - containerHeight) / 2;
            });
        </script>
    </body>
    </html>
</div>
{% endblock %}
