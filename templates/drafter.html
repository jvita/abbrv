{% extends "index.html" %}

{% block content %}
<div class="app2-container">
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Draft</title>
    </head>
    <body>
        <div class="container">
            <div class="main-content">
                <div class="controls">
                    <h2>Editing character</h2>
                    <input type="text" id="character" placeholder="Enter character(s)" autocomplete="off">
                    <div class="d-flex flex-row">
                        <div class="d-flex flex-column flex-grow-1">
                            <h2>Characters</h2>
                            <div id="charactersList" class="spline-list" style="margin-right: 5px;"></div>
                        </div>
                        <div class="d-flex flex-column flex-grow-1">
                            <h2 style="margin-left: 5px">Joins</h2>
                            <div id="joinsList" class="spline-list" style="margin-left: 5px;"></div>
                        </div>
                    </div>
                    <div class="d-flex flex-column justify-content-between">
                        <div>
                            <button id="saveButton">Save</button>
                            <button id="clearButton">Clear</button>
                            <button id="joinButton" style="display:none;">Join</button>
                            <button id="freezeButton" class="freeze-button">Freeze</button>
                            <!-- <button id="deleteButton" class="delete-button" style="display:none">Delete</button> -->
                        </div>
                        <div>
                            <!-- <button id="freezeButton" class="freeze-button">Freeze</button> -->
                            <button id="deleteButton" class="delete-button" style="display:none">Delete</button>
                        </div>
                    </div>
                </div>
                <div class="grid-container">
                    <canvas id="splineCanvas" width="1520" height="1520"></canvas>
                    <canvas id="gridCanvas" width="1520" height="1520"></canvas>
                </div>
            </div>
        </div>
        <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
        <script>
            let charSplineData = {}; // Global variable to store spline data
            let joinsSplineData = {}; // Global variable to store spline data
            const gridCanvas = document.getElementById('gridCanvas');
            const gridCtx = gridCanvas.getContext('2d');
            const splineCanvas = document.getElementById('splineCanvas');
            const splineCtx = splineCanvas.getContext('2d');
            const characterField = document.getElementById('character');
            const saveButton = document.getElementById('saveButton');
            const clearButton = document.getElementById('clearButton');
            const deleteButton = document.getElementById('deleteButton');
            const joinButton = document.getElementById('joinButton');
            const freezeButton = document.getElementById('freezeButton');
            const charactersList = document.getElementById('charactersList');
            const joinsList = document.getElementById('joinsList');

            const rootStyles = getComputedStyle(document.documentElement);
            const colorInk = rootStyles.getPropertyValue('--ink-color').trim()
            const colorSelected = rootStyles.getPropertyValue('--selected-color').trim()
            const colorDarkSelected = rootStyles.getPropertyValue('--dark-selected-color').trim()
            const colorFrozen = rootStyles.getPropertyValue('--frozen-color').trim()

            let selectedPoints = [];
            let joiningPoints = [];
            let frozenPoints = [];
            let selectedCharacter = null;
            let joiningCharacter = null; // Track the currently joining spline
            const gridSize = 76;
            const cellSize = 20;
            const centerOffset = Math.floor(gridSize / 2) * cellSize;

            function drawGrid() {
                gridCtx.clearRect(0, 0, gridCanvas.width, gridCanvas.height);

                // Draw the lighter grid lines
                gridCtx.beginPath();
                gridCtx.strokeStyle = 'rgba(0, 0, 0, 0.1)'; // Very light gray
                gridCtx.lineWidth = 1; // Thin line width
                for (let i = 0; i <= gridSize; i++) {
                    gridCtx.moveTo(i * cellSize, 0);
                    gridCtx.lineTo(i * cellSize, gridCanvas.height);
                    gridCtx.moveTo(0, i * cellSize);
                    gridCtx.lineTo(gridCanvas.width, i * cellSize);
                }
                gridCtx.stroke();

                // Draw the darker center lines
                gridCtx.beginPath();
                gridCtx.strokeStyle = '#000'; // Dark color for center lines
                gridCtx.lineWidth = 1; // Thinner line width for center lines
                const centerX = centerOffset;
                const centerY = centerOffset;

                // Vertical center line
                gridCtx.moveTo(centerX, 0);
                gridCtx.lineTo(centerX, gridCanvas.height);

                // Horizontal center line
                gridCtx.moveTo(0, centerY);
                gridCtx.lineTo(gridCanvas.width, centerY);

                gridCtx.stroke();

                // Draw the dark center squares
                gridCtx.beginPath();
                gridCtx.strokeStyle = '#000';
                gridCtx.lineWidth = 1;
                gridCtx.strokeRect(centerX - 120, centerY - 120, 240, 240);
                gridCtx.strokeRect(centerX - 240, centerY - 240, 480, 480);
                gridCtx.strokeRect(centerX - 360, centerY - 360, 720, 720);
                gridCtx.strokeRect(centerX - 480, centerY - 480, 960, 960);
                gridCtx.strokeRect(centerX - 600, centerY - 600, 1200, 1200);
                gridCtx.strokeRect(centerX - 720, centerY - 720, 1440, 1440);
                gridCtx.stroke();
            }

            function drawPoints() {
                gridCtx.clearRect(0, 0, gridCanvas.width, gridCanvas.height); // Clear the grid canvas before redrawing
                drawGrid(); // Redraw the grid
                gridCtx.fillStyle = colorSelected; // Color for knot points
                selectedPoints.forEach(([x, y]) => {
                    gridCtx.beginPath();
                    gridCtx.arc(centerOffset + x * cellSize, centerOffset - y * cellSize, 5, 0, Math.PI * 2);
                    gridCtx.fill();
                });
            }

            function updatePointsField() {
                splineCtx.clearRect(0, 0, splineCanvas.width, splineCanvas.height); // Clear spline visualization

                if (frozenPoints.length > 0) {
                    const frozenNormalizedPointsSelected = frozenPoints.map(([x, y]) => [(x + gridSize / 2) / gridSize, (y + gridSize / 2) / gridSize]);
                    plotSpline(frozenNormalizedPointsSelected , colorFrozen);
                }

                drawPoints(); // Draw new points

                // Calculate the shift required to align the joining char to the selected char
                if (joiningPoints.length > 0) {
                    let lastX = 0;
                    let lastY = 0;

                    if (selectedPoints.length > 0) {
                        [lastX, lastY] = selectedPoints[0];
                    }

                    const [firstX, firstY] = joiningPoints[joiningPoints.length - 1]
                    const shiftedJoinPoints = joiningPoints.map(([x, y]) => [x - firstX + lastX, y - firstY + lastY]);
                    const normalizedPointsJoining = shiftedJoinPoints.map(([x, y]) => [(x + gridSize / 2) / gridSize, (y + gridSize / 2) / gridSize]);
                    // plotSpline(normalizedPointsJoining, colorDarkSelected);
                    plotSpline(normalizedPointsJoining);
                }

                const normalizedPointsSelected = selectedPoints.map(([x, y]) => [(x + gridSize / 2) / gridSize, (y + gridSize / 2) / gridSize]);
                plotSpline(normalizedPointsSelected);
            }

            function plotSpline(points, color = colorInk) {
                if (points.length < 2) {
                    splineCtx.clearRect(0, 0, splineCanvas.width, splineCanvas.height);
                    return;
                }

                axios.post('/spline', { points })
                    .then(response => {
                        splineCtx.beginPath();
                        splineCtx.lineWidth = 2; // Thicker line width for spline
                        splineCtx.strokeStyle = color
                        const spline = response.data.spline;
                        spline.forEach(([x, y], index) => {
                            const plotX = (x + (gridSize / 2)) * (splineCanvas.width / gridSize);
                            const plotY = splineCanvas.height - ((y + (gridSize / 2)) * (splineCanvas.height / gridSize));
                            if (index === 0) {
                                splineCtx.moveTo(plotX, plotY);
                            } else {
                                splineCtx.lineTo(plotX, plotY);
                            }
                        });
                        splineCtx.stroke();
                    });
            }

            gridCanvas.addEventListener('click', (event) => {
                // if (joiningCharacter) return; // Prevent point selection if a spline is joining

                const rect = gridCanvas.getBoundingClientRect();
                const x = event.clientX - rect.left - centerOffset;
                const y = rect.top + centerOffset - event.clientY;
                const gridX = Math.round(x / cellSize);
                const gridY = Math.round(y / cellSize);

                const isCtrlPressed = event.ctrlKey;

                if (isCtrlPressed) {
                    const pointIndex = selectedPoints.findLastIndex(([px, py]) => Math.round(px) === gridX && Math.round(py) === gridY);
                    // Ctrl+click: Remove the point if it exists
                    if (pointIndex !== -1) {
                        selectedPoints.splice(pointIndex, 1);
                    }
                } else {
                    // Regular click
                    selectedPoints.push([gridX, gridY]);
                }

                updatePointsField();
            });

            function handleCharSelect(char, points = null) {
                selectedCharacter = char;
                selectedPoints = points ? points : (char ? charSplineData[selectedCharacter] : [])
                selectedPoints = selectedPoints.map(([x, y]) => [x * gridSize - gridSize / 2, y * gridSize - gridSize / 2]);

                characterField.value = char ? char : '';

                // update coloring of spline list
                document.querySelectorAll('.char-list-item').forEach(item => {
                    if (item.textContent === char) {
                        if (item.classList.contains('selected')) {  // on -> off
                            item.classList.remove('selected');
                        } else {  // off -> on
                            item.classList.add('selected');
                            item.scrollIntoView({ behavior: 'smooth', block: 'start' });
                        }
                    } else {
                        if (item.classList.contains('selected')) {  // on -> off
                            item.classList.remove('selected');
                        }
                    }
                });
            }

            function handleJoinSelect(prev) {
                joiningCharacter = prev;
                joiningPoints = prev ? charSplineData[prev] : [];
                joiningPoints = joiningPoints.map(([x, y]) => [x * gridSize - gridSize / 2, y * gridSize - gridSize / 2]);

                // update coloring of spline list
                document.querySelectorAll('.char-list-item').forEach(item => {
                    item.classList.remove('joining');
                    if (item.textContent === prev ) {
                        item.classList.add('joining');
                        if (item.classList.contains('selected')) {
                            item.classList.remove('selected');
                        }
                    } else {
                        if (item.classList.contains('joining')) {
                            item.classList.remove('joining');
                        }
                    }
                });
            }

            function handleJoinAndCharSelect(prev, char){
                handleJoinSelect(prev)

                const newPoints = ((char in joinsSplineData) && (prev in joinsSplineData[char])) ? joinsSplineData[char][prev] : null;
                handleCharSelect(char, newPoints);

                // update coloring of spline list
                document.querySelectorAll('.join-list-item').forEach(item => {
                    item.classList.remove('selected');
                    if (item.textContent === prev+char ) {
                        if (item.classList.contains('selected')) {
                            item.classList.remove('selected');
                        } else {
                            item.classList.add('selected');
                            item.scrollIntoView({ behavior: 'smooth', block: 'start' });
                        }
                    } else {
                        if (item.classList.contains('selected')) {
                            item.classList.remove('selected');
                        }
                    }
                });
            }

            saveButton.addEventListener('click', () => {
                const character = characterField.value.trim();
                if (character && selectedPoints.length) {
                    const data = {
                        character: character,
                        joinchar: joiningCharacter,
                        points: selectedPoints.map(([x, y]) => [(x + gridSize / 2) / gridSize, (y + gridSize / 2) / gridSize]),
                    };
                    axios.post('/save', data)
                        .then(response => {
                            if (response.data.status === 'success') {
                                loadJoins();  // to re-add the new data
                                loadCharacters();
                                handleJoinAndCharSelect(null, null);
                                refreshJoinButton();
                                refreshDeleteButton();
                                updatePointsField();
                                characterField.value = '';
                                characterField.focus();
                            }
                        });
                }

            });

            clearButton.addEventListener('click', () => {
                selectedPoints = [];
                updatePointsField();
            });

            deleteButton.addEventListener('click', () => {
                if (selectedCharacter) {
                    axios.post('/delete', { character: selectedCharacter , joinchar: joiningCharacter})
                        .then(response => {
                            if (response.data.status === 'success') {
                                loadJoins();  // to re-add the new data
                                loadCharacters();
                                handleJoinAndCharSelect(null, null);
                                refreshJoinButton();
                                refreshDeleteButton();
                                updatePointsField();
                                characterField.value = '';
                                characterField.focus();
                            }
                        });
                }
            });

            function loadCharacters() {
                axios.get('/load_characters')
                    .then(response => {

                        charSplineData = response.data; // Store the data in the global variable
                        charactersList.innerHTML = '';
                        deleteButton.style.display = 'none'; // Hide delete button initially

                        splineCtx.clearRect(0, 0, splineCanvas.width, splineCanvas.height);

                        for (const [character, points] of Object.entries(charSplineData)) {
                            const listItem = document.createElement('div');
                            listItem.className = 'char-list-item';
                            listItem.textContent = character;

                            listItem.addEventListener('click', () => {
                                const prevSelected = listItem.classList.contains('selected');

                                // handleCharSelect(!prevSelected ? character: null)
                                handleJoinAndCharSelect(joiningCharacter, !prevSelected ? character : null)
                                refreshJoinButton();
                                refreshDeleteButton();
                                updatePointsField();
                            });
                            charactersList.appendChild(listItem);
                        }
                    });
            }

            function loadJoins() {
                axios.get('/load_joins')
                    .then(response => {

                        charSplineData = response.data['chars'];
                        joinsSplineData = response.data['joins'];
                        joinsList.innerHTML = '';
                        deleteButton.style.display = 'none'; // Hide delete button initially
                        joinButton.style.display = 'none'; // Hide delete button initially

                        splineCtx.clearRect(0, 0, splineCanvas.width, splineCanvas.height);

                        for (const [character, charPoints] of Object.entries(charSplineData)) {
                            if (!(character in joinsSplineData)) {
                                continue
                            }

                            for (const [joinchar, joinPoints] of Object.entries(joinsSplineData[character])) {
                                const listItem = document.createElement('div');
                                listItem.className = 'join-list-item';
                                listItem.textContent = joinchar+character;
                                listItem.addEventListener('click', () => {
                                    const prevSelected = listItem.classList.contains('selected');

                                    handleJoinAndCharSelect(
                                        !prevSelected ? joinchar: null,
                                        !prevSelected ? character: null,
                                    )
                                    refreshJoinButton();
                                    refreshDeleteButton();
                                    updatePointsField();
                                });

                                // Make sure selected character is always highlighted
                                joinsList.appendChild(listItem);
                            }
                        }
                    });
            }

            joinButton.addEventListener('click', () => {
                handleJoinAndCharSelect(
                    joiningCharacter ? null : selectedCharacter,
                    null
                )
                refreshJoinButton();
                refreshDeleteButton();
                updatePointsField();

                // to make it easier to continue typing a join after clicking "Join"
                characterField.focus();
            });

            function refreshJoinButton() {
                joinButton.style.display = (joiningCharacter || selectedCharacter) ? 'inline-block' : 'none';
                joinButton.textContent = joiningCharacter ? 'Unjoin' : 'Join';
                joinButton.style.backgroundColor = joiningCharacter ? colorDarkSelected : colorSelected;
            }

            function refreshDeleteButton() {
                deleteButton.style.display = selectedCharacter ? 'inline-block' : 'none';
            }

            document.getElementById('character').onkeyup = sortAndDisplayList;

            function sortAndDisplayList() {
                sortOneList(charactersList);
                sortOneList(joinsList);

                // select the top result if it exists
                const searchTerm = document.getElementById('character').value.toLowerCase();

                if ((searchTerm) && (searchTerm in charSplineData)) {  // select
                    const topResult = charactersList.children[0];
                    handleJoinAndCharSelect(joiningCharacter, topResult.textContent)
                    topResult.classList.add('selected');
                }

                refreshJoinButton();
                refreshDeleteButton();
                updatePointsField();
            }

            function sortOneList(listToSort) {
                // Get the value from the character input field
                const searchTerm = document.getElementById('character').value.toLowerCase();

                // Get current list items
                let listItems = Array.from(listToSort.children);

                // Function to check if an item contains the search term
                const containsSearchTerm = text => text.toLowerCase().includes(searchTerm);
                const startsWithSearchTerm = text => text.toLowerCase().startsWith(searchTerm);

                // Separate items into those that start with the search term, those that contain it elsewhere, and those that do not contain it
                let startsWithItems = listItems.filter(item => startsWithSearchTerm(item.textContent));
                let containsItems = listItems.filter(item => containsSearchTerm(item.textContent) && !startsWithSearchTerm(item.textContent));
                let nonMatchingItems = listItems.filter(item => !containsSearchTerm(item.textContent));

                // Sort each array alphabetically
                startsWithItems.sort((a, b) => a.textContent.toLowerCase().localeCompare(b.textContent.toLowerCase()));
                containsItems.sort((a, b) => a.textContent.toLowerCase().localeCompare(b.textContent.toLowerCase()));
                nonMatchingItems.sort((a, b) => a.textContent.toLowerCase().localeCompare(b.textContent.toLowerCase()));

                // Combine the arrays: items starting with the search term first, then items containing it elsewhere, then non-matching items
                let sortedItems = startsWithItems.concat(containsItems, nonMatchingItems);

                // Clear the current list and re-append sorted items
                listToSort.innerHTML = '';
                sortedItems.forEach(item => {
                    listToSort.appendChild(item);
                });
            }

            drawGrid();
            loadJoins();
            loadCharacters();

            document.addEventListener("DOMContentLoaded", function() {
                const gridContainer = document.querySelector('.grid-container');
                const containerWidth = gridContainer.clientWidth;
                const containerHeight = gridContainer.clientHeight;
                const gridWidth = 1520;
                const gridHeight = 1520;

                gridContainer.scrollLeft = (gridWidth - containerWidth) / 2;
                gridContainer.scrollTop = (gridHeight - containerHeight) / 2;
            });

            characterField.focus();
        </script>
    </body>
    </html>
</div>
{% endblock %}
