{% extends "index.html" %}

{% block content %}
<div class="container">
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Draft</title>
    </head>
    <body>
        <div class="container">
            <div class="main-content">
                <div class="controls">
                    <h2>Drafting character</h2>
                    <input type="text" id="character" placeholder="Enter character(s)" autocomplete="off">
                    <div class="d-flex flex-row" style="margin:5px;">
                        <div class="d-flex flex-column flex-grow-1">
                            <h2>Characters</h2>
                            <div id="charactersList" class="spline-list" style="margin-right: 5px;"></div>
                        </div>
                        <div class="d-flex flex-column flex-grow-1">
                            <h2 style="margin-left: 5px">Joins</h2>
                            <div id="joinsList" class="spline-list" style="margin-left: 5px;"></div>
                        </div>
                    </div>
                    <div class="d-flex flex-column">
                        <div class="d-flex justify-content-between">
                            <div class="d-flex">
                                <button id="saveButton" type="button" class="btn btn-primary">Save</button>
                                <button id="clearButton" type="button" class="btn btn-primary">Clear</button>
                                <button id="joinButton" type="button" class="btn btn-primary" disabled>Join</button>
                            </div>
                            <button id="freezeButton" type="button" class="btn btn-primary" disabled>Freeze</button>
                        </div>
                        <button id="deleteButton" type="button" class="btn btn-danger" disabled>Delete</button>
                    </div>
                </div>
                <div class="grid-container">
                    <canvas id="splineCanvas" width="1520" height="1520"></canvas>
                    <canvas id="gridCanvas" width="1520" height="1520"></canvas>
                </div>
            </div>
        </div>
        <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
        <script>
            let charSplineData = {}; // Global variable to store spline data
            let joinsSplineData = {}; // Global variable to store spline data
            const gridCanvas = document.getElementById('gridCanvas');
            const gridCtx = gridCanvas.getContext('2d');
            const splineCanvas = document.getElementById('splineCanvas');
            const splineCtx = splineCanvas.getContext('2d');
            const characterField = document.getElementById('character');
            const saveButton = document.getElementById('saveButton');
            const clearButton = document.getElementById('clearButton');
            const deleteButton = document.getElementById('deleteButton');
            const joinButton = document.getElementById('joinButton');
            const freezeButton = document.getElementById('freezeButton');
            const charactersList = document.getElementById('charactersList');
            const joinsList = document.getElementById('joinsList');

            const rootStyles = getComputedStyle(document.documentElement);
            const colorInk = rootStyles.getPropertyValue('--ink-color').trim()
            const colorSelected = rootStyles.getPropertyValue('--selected-color').trim()
            const colorDarkSelected = rootStyles.getPropertyValue('--dark-selected-color').trim()
            const colorFreeze = rootStyles.getPropertyValue('--freeze-color').trim()
            const colorFrozen = rootStyles.getPropertyValue('--frozen-color').trim()
            const colorDisabled = rootStyles.getPropertyValue('--disabled-color').trim()

            let selectedPoints = [];
            let joiningPoints = [];
            let frozenCharPoints = [];
            // let frozenJoinPoints = [];
            let frozenChar = null;
            // let frozenJoin = null;
            let selectedCharacter = null;
            let joiningCharacter = null; // Track the currently joining spline
            const gridSize = 76;
            const cellSize = 20;
            const centerOffset = Math.floor(gridSize / 2) * cellSize;

            function drawGrid() {
                gridCtx.clearRect(0, 0, gridCanvas.width, gridCanvas.height);

                // Draw the lighter grid lines
                gridCtx.beginPath();
                gridCtx.strokeStyle = 'rgba(0, 0, 0, 0.1)'; // Very light gray
                gridCtx.lineWidth = 1; // Thin line width
                for (let i = 0; i <= gridSize; i++) {
                    gridCtx.moveTo(i * cellSize, 0);
                    gridCtx.lineTo(i * cellSize, gridCanvas.height);
                    gridCtx.moveTo(0, i * cellSize);
                    gridCtx.lineTo(gridCanvas.width, i * cellSize);
                }
                gridCtx.stroke();

                // Draw the darker center lines
                gridCtx.beginPath();
                gridCtx.strokeStyle = '#000'; // Dark color for center lines
                gridCtx.lineWidth = 1; // Thinner line width for center lines
                const centerX = centerOffset;
                const centerY = centerOffset;

                // Vertical center line
                gridCtx.moveTo(centerX, 0);
                gridCtx.lineTo(centerX, gridCanvas.height);

                // Horizontal center line
                gridCtx.moveTo(0, centerY);
                gridCtx.lineTo(gridCanvas.width, centerY);

                gridCtx.stroke();

                // Draw the dark center squares
                gridCtx.beginPath();
                gridCtx.strokeStyle = '#000';
                gridCtx.lineWidth = 1;
                gridCtx.strokeRect(centerX - 120, centerY - 120, 240, 240);
                gridCtx.strokeRect(centerX - 240, centerY - 240, 480, 480);
                gridCtx.strokeRect(centerX - 360, centerY - 360, 720, 720);
                gridCtx.strokeRect(centerX - 480, centerY - 480, 960, 960);
                gridCtx.strokeRect(centerX - 600, centerY - 600, 1200, 1200);
                gridCtx.strokeRect(centerX - 720, centerY - 720, 1440, 1440);
                gridCtx.stroke();
            }

            function drawPoints(points = null, color = colorSelected) {
                // drawGrid(); // Redraw the grid
                splineCtx.fillStyle = color; // Color for knot points
                if (!points) {
                    selectedPoints.forEach(([x, y]) => {
                        splineCtx.beginPath();
                        splineCtx.arc(centerOffset + x * cellSize, centerOffset - y * cellSize, 5, 0, Math.PI * 2);
                        splineCtx.fill();
                    });
                } else {
                    points.forEach(([x, y]) => {
                        splineCtx.beginPath();
                        splineCtx.arc(centerOffset + x * cellSize, centerOffset - y * cellSize, 5, 0, Math.PI * 2);
                        splineCtx.fill();
                    });
                }
            }

            function updatePointsField() {
                drawGrid(); // Redraw the grid
                splineCtx.clearRect(0, 0, splineCanvas.width, splineCanvas.height); // Clear spline visualization

                // Paint frozen char and join separately
                if (frozenCharPoints.length > 0) {
                    const frozenNormalizedCharPointsSelected = frozenCharPoints.map(([x, y]) => [(x + gridSize / 2) / gridSize, (y + gridSize / 2) / gridSize]);

                    const color = getComputedStyle(freezeButton)['background-color']
                    plotSpline(frozenNormalizedCharPointsSelected, color, () => drawPoints(frozenCharPoints, color));
                }

                // if (frozenJoinPoints.length > 0) {
                //     const frozenNormalizedJoinPointsSelected = frozenJoinPoints.map(([x, y]) => [(x + gridSize / 2) / gridSize, (y + gridSize / 2) / gridSize]);
                //     plotSpline(frozenNormalizedJoinPointsSelected, colorFrozen, () => drawPoints(frozenJoinPoints, colorFrozen));
                // }

                // Calculate the shift required to align the joining char to the selected char
                if (joiningPoints.length > 0) {
                    let lastX = 0;
                    let lastY = 0;

                    if (selectedPoints.length > 0) {
                        [lastX, lastY] = selectedPoints[0];
                    }

                    const [firstX, firstY] = joiningPoints[joiningPoints.length - 1];
                    const shiftedJoinPoints = joiningPoints.map(([x, y]) => [x - firstX + lastX, y - firstY + lastY]);
                    const normalizedPointsJoining = shiftedJoinPoints.map(([x, y]) => [(x + gridSize / 2) / gridSize, (y + gridSize / 2) / gridSize]);
                    plotSpline(normalizedPointsJoining, colorInk);
                }

                const normalizedPointsSelected = selectedPoints.map(([x, y]) => [(x + gridSize / 2) / gridSize, (y + gridSize / 2) / gridSize]);
                plotSpline(normalizedPointsSelected, colorInk, () => drawPoints(selectedPoints));
            }

            function plotSpline(points, color = colorInk, callback = null) {
                if (points.length < 2) {
                    return;
                }

                axios.post('/spline', { points })
                    .then(response => {
                        splineCtx.beginPath();
                        splineCtx.lineWidth = 4; // Thicker line width for spline
                        splineCtx.strokeStyle = color;
                        const spline = response.data.spline;
                        spline.forEach(([x, y], index) => {
                            const plotX = (x + (gridSize / 2)) * (splineCanvas.width / gridSize);
                            const plotY = splineCanvas.height - ((y + (gridSize / 2)) * (splineCanvas.height / gridSize));
                            if (index === 0) {
                                splineCtx.moveTo(plotX, plotY);
                            } else {
                                splineCtx.lineTo(plotX, plotY);
                            }
                        });
                        splineCtx.stroke();
                        
                        // Call the callback if provided
                        if (callback) {
                            callback();
                        }
                    });
            }



            gridCanvas.addEventListener('click', (event) => {
                // if (joiningCharacter) return; // Prevent point selection if a spline is joining

                const rect = gridCanvas.getBoundingClientRect();
                const x = event.clientX - rect.left - centerOffset;
                const y = rect.top + centerOffset - event.clientY;
                const gridX = Math.round(x / cellSize);
                const gridY = Math.round(y / cellSize);

                const isCtrlPressed = event.ctrlKey;

                if (isCtrlPressed) {
                    const pointIndex = selectedPoints.findLastIndex(([px, py]) => Math.round(px) === gridX && Math.round(py) === gridY);
                    // Ctrl+click: Remove the point if it exists
                    if (pointIndex !== -1) {
                        selectedPoints.splice(pointIndex, 1);
                    }
                } else {
                    // Regular click
                    selectedPoints.push([gridX, gridY]);
                }

                updatePointsField();
            });

            function handleCharSelect(char, points = null) {
                selectedCharacter = char;
                selectedPoints = points ? points : (char ? charSplineData[selectedCharacter] : [])
                selectedPoints = selectedPoints.map(([x, y]) => [x * gridSize - gridSize / 2, y * gridSize - gridSize / 2]);

                characterField.value = char ? char : '';

                // update coloring of spline list
                document.querySelectorAll('.char-list-item').forEach(item => {
                    if (item.textContent === char) {
                        if (item.classList.contains('selected')) {  // on -> off
                            item.classList.remove('selected');
                        } else {  // off -> on
                            item.classList.add('selected');
                            item.scrollIntoView({ behavior: 'smooth', block: 'start' });
                        }
                    } else {
                        if (item.classList.contains('selected')) {  // on -> off
                            item.classList.remove('selected');
                        }
                    }
                });
            }

            function handleJoinSelect(prev) {
                joiningCharacter = prev;
                joiningPoints = prev ? charSplineData[prev] : [];
                joiningPoints = joiningPoints.map(([x, y]) => [x * gridSize - gridSize / 2, y * gridSize - gridSize / 2]);

                // update coloring of spline list
                document.querySelectorAll('.char-list-item').forEach(item => {
                    item.classList.remove('joining');
                    if (item.textContent === prev ) {
                        item.classList.add('joining');
                        if (item.classList.contains('selected')) {
                            item.classList.remove('selected');
                        }
                    } else {
                        if (item.classList.contains('joining')) {
                            item.classList.remove('joining');
                        }
                    }
                });
            }

            function handleJoinAndCharSelect(prev, char){
                handleJoinSelect(prev)

                const newPoints = ((char in joinsSplineData) && (prev in joinsSplineData[char])) ? joinsSplineData[char][prev] : null;
                handleCharSelect(char, newPoints);

                // update coloring of joins list and scroll into view
                document.querySelectorAll('.join-list-item').forEach(item => {
                    item.classList.remove('selected');
                    if (item.textContent === prev+char ) {
                        if (item.classList.contains('selected')) {
                            item.classList.remove('selected');
                        } else {
                            item.classList.add('selected');
                            item.scrollIntoView({ behavior: 'smooth', block: 'start' });
                        }
                    } else {
                        if (item.classList.contains('selected')) {
                            item.classList.remove('selected');
                        }
                    }
                });
            }

            saveButton.addEventListener('click', () => {
                const character = characterField.value.trim();
                if (character && selectedPoints.length) {
                    const data = {
                        character: character,
                        joinchar: joiningCharacter,
                        points: selectedPoints.map(([x, y]) => [(x + gridSize / 2) / gridSize, (y + gridSize / 2) / gridSize]),
                    };
                    axios.post('/save', data)
                        .then(response => {
                            if (response.data.status === 'success') {
                                loadJoins();  // to re-add the new data
                                loadCharacters();
                                handleJoinAndCharSelect(null, null);
                                refreshJoinButton();
                                refreshDeleteButton();
                                refreshFreezeButton()
                                updatePointsField();
                                characterField.value = '';
                                characterField.focus();
                            }
                        });
                }

            });

            clearButton.addEventListener('click', () => {
                selectedPoints = [];
                updatePointsField();
            });

            deleteButton.addEventListener('click', () => {
                if (selectedCharacter) {
                    axios.post('/delete', { character: selectedCharacter , joinchar: joiningCharacter})
                        .then(response => {
                            if (response.data.status === 'success') {
                                loadJoins();  // to re-add the new data
                                loadCharacters();
                                handleJoinAndCharSelect(null, null);
                                refreshJoinButton();
                                refreshDeleteButton();
                                refreshFreezeButton()
                                updatePointsField();
                                characterField.value = '';
                                characterField.focus();
                            }
                        });
                }
            });

            function loadCharacters() {
                axios.get('/load_characters')
                    .then(response => {

                        charSplineData = response.data; // Store the data in the global variable
                        charactersList.innerHTML = '';
                        // deleteButton.style.display = 'none'; // Hide delete button initially


                        for (const [character, points] of Object.entries(charSplineData)) {
                            const listItem = document.createElement('div');
                            listItem.className = 'char-list-item';
                            listItem.textContent = character;

                            listItem.addEventListener('click', () => {
                                const prevSelected = listItem.classList.contains('selected');

                                // handleCharSelect(!prevSelected ? character: null)
                                handleJoinAndCharSelect(joiningCharacter, !prevSelected ? character : null)
                                refreshJoinButton();
                                refreshDeleteButton();
                                refreshFreezeButton()
                                updatePointsField();
                            });
                            charactersList.appendChild(listItem);
                        }
                    });
            }

            function loadJoins() {
                axios.get('/load_joins')
                    .then(response => {

                        charSplineData = response.data['chars'];
                        joinsSplineData = response.data['joins'];
                        joinsList.innerHTML = '';
                        // deleteButton.style.display = 'none'; // Hide delete button initially
                        // joinButton.style.display = 'none'; // Hide delete button initially


                        for (const [character, charPoints] of Object.entries(charSplineData)) {
                            if (!(character in joinsSplineData)) {
                                continue
                            }

                            for (const [joinchar, joinPoints] of Object.entries(joinsSplineData[character])) {
                                const listItem = document.createElement('div');
                                listItem.className = 'join-list-item';
                                listItem.textContent = joinchar+character;
                                listItem.addEventListener('click', () => {
                                    const prevSelected = listItem.classList.contains('selected');

                                    handleJoinAndCharSelect(
                                        !prevSelected ? joinchar: null,
                                        !prevSelected ? character: null,
                                    )
                                    refreshJoinButton();
                                    refreshDeleteButton();
                                    refreshFreezeButton()
                                    updatePointsField();
                                });

                                // Make sure selected character is always highlighted
                                joinsList.appendChild(listItem);
                            }
                        }
                    });
            }

            joinButton.addEventListener('click', () => {

                if (joiningCharacter && selectedCharacter) {
                    // drop the selected, make the join the selected
                    handleJoinAndCharSelect(null, joiningCharacter)
                } else if (joiningCharacter) {
                    // make the join the selected
                    handleJoinAndCharSelect(null, joiningCharacter)
                } else if (selectedCharacter) {
                    // make the selected the join
                    handleJoinAndCharSelect(selectedCharacter, null)
                }

                refreshJoinButton();
                refreshDeleteButton();
                refreshFreezeButton()
                updatePointsField();

                // to make it easier to continue typing a join after clicking "Join"
                characterField.focus();
            });

            freezeButton.addEventListener('click', () => {
                splineCtx.clearRect(0, 0, splineCanvas.width, splineCanvas.height);
                if (freezeButton.textContent === 'Freeze') {
                    frozenCharPoints = selectedPoints;
                    // frozenJoinPoints = joiningPoints;
                    selectedPoints = []
                    // joiningPoints = []

                    frozenChar = selectedCharacter;
                    // frozenJoin = joiningCharacter;

                    selectedCharacter = null;
                    // joiningCharacter = null;
                } else {
                    selectedPoints = frozenCharPoints;
                    // joiningPoints = frozenJoinPoints;

                    selectedCharacter = frozenChar;
                    // joiningCharacter = frozenJoin ;

                    frozenChar = null;
                    // frozenJoin = null;
                    frozenCharPoints = [];
                    // frozenJoinPoints = [];
                }
                freezeButton.textContent = (freezeButton.textContent === 'Freeze') ? 'Unfreeze' : 'Freeze';
                handleJoinAndCharSelect(joiningCharacter, selectedCharacter)
                refreshFreezeButton();
                updatePointsField();
                characterField.focus();
            })

            function refreshJoinButton() {
                // joinButton.style.display = (joiningCharacter || selectedCharacter) ? 'inline-block' : 'none';
                joinButton.textContent = joiningCharacter ? 'Unjoin' : 'Join';

                // check if disabled
                joinButton.disabled = (joiningCharacter || selectedCharacter) == null

                // if (joinButton.disabled) {
                //     // remove other classes so that it doesn't overload hover behavior
                //     if (joinButton.classList.contains('join-button')) {
                //         joinButton.classList.remove('join-button')
                //     }
                //     if (joinButton.classList.contains('unjoin-button')) {
                //         joinButton.classList.remove('unjoin-button')
                //     }
                // } else {
                //     if (joiningCharacter) {  // if joining, turn it into an Unjoin button
                //         if (joinButton.classList.contains('join-button')) {
                //             joinButton.classList.remove('join-button')
                //         }
                //         joinButton.classList.add('unjoin-button')
                //     } else {  // not joining, so make it a join button
                //         if (joinButton.classList.contains('unjoin-button')) {
                //             joinButton.classList.remove('unjoin-button')
                //         }
                //         joinButton.classList.add('join-button')
                //     }
                // }
        }

            function refreshFreezeButton() {
                // freezeButton.disabled =  (selectedCharacter || joiningCharacter) == null
                freezeButton.disabled = ((joiningCharacter || selectedCharacter) == null) && (frozenChar == null)
                // if (freezeButton.disabled) {
                //     // disabled; so make sure it's greyed out
                //     if (freezeButton.classList.contains('freeze-button')) {
                //         freezeButton.classList.remove('freeze-button')
                //     }
                // } else {
                //     // enabled; color it, then do stuff
                //     if (!freezeButton.classList.contains('freeze-button')) {
                //         // freezeButton.classList.add('freeze-button')
                //     }
                // }
            }

            function refreshDeleteButton() {
                deleteButton.disabled =  (selectedCharacter || joiningCharacter) == null
                if (deleteButton.disabled) {
                    if (deleteButton.classList.contains('delete-button')) {
                        deleteButton.classList.remove('delete-button')
                    }
                } else {
                    if (!deleteButton.classList.contains('delete-button')) {
                        // deleteButton.classList.add('delete-button')
                    }
                }
            }

            characterField.addEventListener('keyup', function(event) {
                if (event.key === 'Control' && !event.altKey && !event.shiftKey && !event.metaKey) {
                    joinButton.click()
                } else if (event.key === 'Shift') {
                    freezeButton.click();
                }
                else {
                    sortAndDisplayList();
                }
            })

            function sortAndDisplayList() {
                sortOneList(charactersList);
                sortOneList(joinsList);

                // select the top result if it exists
                const searchTerm = document.getElementById('character').value.toLowerCase();

                if ((searchTerm) && (searchTerm in charSplineData)) {  // select
                    const topResult = charactersList.children[0];
                    handleJoinAndCharSelect(joiningCharacter, topResult.textContent)
                    topResult.classList.add('selected');
                } else {
                    // deselect
                    handleJoinAndCharSelect(null, null)
                }

                refreshJoinButton();
                refreshDeleteButton();
                refreshFreezeButton()
                updatePointsField();
            }

            function sortOneList(listToSort) {
                // Get the value from the character input field
                const searchTerm = document.getElementById('character').value.toLowerCase();

                // Get current list items
                let listItems = Array.from(listToSort.children);

                // Function to check if an item contains the search term
                const containsSearchTerm = text => text.toLowerCase().includes(searchTerm);
                const startsWithSearchTerm = text => text.toLowerCase().startsWith(searchTerm);

                // Separate items into those that start with the search term, those that contain it elsewhere, and those that do not contain it
                let startsWithItems = listItems.filter(item => startsWithSearchTerm(item.textContent));
                let containsItems = listItems.filter(item => containsSearchTerm(item.textContent) && !startsWithSearchTerm(item.textContent));
                let nonMatchingItems = listItems.filter(item => !containsSearchTerm(item.textContent));

                // Sort each array alphabetically
                startsWithItems.sort((a, b) => a.textContent.toLowerCase().localeCompare(b.textContent.toLowerCase()));
                containsItems.sort((a, b) => a.textContent.toLowerCase().localeCompare(b.textContent.toLowerCase()));
                nonMatchingItems.sort((a, b) => a.textContent.toLowerCase().localeCompare(b.textContent.toLowerCase()));

                // Combine the arrays: items starting with the search term first, then items containing it elsewhere, then non-matching items
                let sortedItems = startsWithItems.concat(containsItems, nonMatchingItems);

                // Clear the current list and re-append sorted items
                listToSort.innerHTML = '';
                sortedItems.forEach(item => {
                    listToSort.appendChild(item);
                });
            }

            refreshJoinButton();
            refreshDeleteButton();
            refreshFreezeButton()
            drawGrid();
            loadJoins();
            loadCharacters();

            document.addEventListener("DOMContentLoaded", function() {
                const gridContainer = document.querySelector('.grid-container');
                const containerWidth = gridContainer.clientWidth;
                const containerHeight = gridContainer.clientHeight;
                const gridWidth = 1520;
                const gridHeight = 1520;

                gridContainer.scrollLeft = (gridWidth - containerWidth) / 2;
                gridContainer.scrollTop = (gridHeight - containerHeight) / 2;
            });

            characterField.focus();
        </script>
    </body>
    </html>
</div>
{% endblock %}
