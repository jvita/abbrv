{% extends "index.html" %}

{% block content %}
<div class="main-content">
    <div class="controls">
        <div class="d-flex flex-row" style="margin:5px;">
            <div class="d-flex flex-column flex-grow-1">
                <h2 id="glyphsTitle">Glyphs</h2>
                <div id="glyphsList" class="spline-list" style="margin-right: 5px;"></div>
            </div>
            <div class="d-flex flex-column flex-grow-1">
                <h2 id="modesTitle">Modes</h2>
                <div id="modesList" class="spline-list"></div>
            </div>
        </div>
        <input type="text" id="character" placeholder="Enter character(s)" autocomplete="off">
        <div class="d-flex flex-column">
            <div class="d-flex justify-content-between">
                <div class="btn-group">
                    <button id="clearButton" type="button" class="btn btn-primary">Clear</button>
                    <button id="clearAllDropdown" type="button" class="btn btn-primary dropdown-toggle dropdown-toggle-split" data-bs-toggle="dropdown" aria-expanded="false">
                        <span class="visually-hidden">Toggle Dropdown</span>
                    </button>
                    <ul class="dropdown-menu">
                        <li><a id="clearAllButton" class="dropdown-item" href="#" id="clearAllOption">all</a></li>
                    </ul>
                </div>
                <button id="freezeButton" type="button" class="btn btn-primary" disabled>Freeze</button>
                <div class="btn-group">
                    <button id="saveButton" type="button" class="btn btn-primary">Save</button>
                    <button id="saveDropdown" type="button" class="btn btn-primary dropdown-toggle dropdown-toggle-split" data-bs-toggle="dropdown" aria-expanded="false">
                        <span class="visually-hidden">Toggle Dropdown</span>
                    </button>
                    <ul class="dropdown-menu">
                        <li><a id="saveMode" class="dropdown-item" href="#" id="saveAsOption">as mode</a></li>
                    </ul>
                </div>
            </div>
            <div class="btn-group d-flex">
                <button id="deleteButton" type="button" class="btn btn-danger flex-grow-1">Delete</button>
                <button id="deleteDropdown" type="button" class="btn btn-danger dropdown-toggle dropdown-toggle-split flex-grow-0" data-bs-toggle="dropdown" aria-expanded="false">
                    <span class="visually-hidden">Toggle Dropdown</span>
                </button>
                <ul class="dropdown-menu">
                    <li><a id="deleteMode" class="dropdown-item" href="#" id="deleteAsOption">as mode</a></li>
                </ul>
            </div>
        </div>
    </div>
    <div class="grid-container">
        <canvas id="splineCanvas" width="1520" height="1520"></canvas>
        <canvas id="gridCanvas" width="1520" height="1520"></canvas>
    </div>
</div>
<script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
<script>
let charSplineData = {}; // Global variable to store spline data
let modeSplineData = {}; // Global variable to store spline data
const gridCanvas = document.getElementById('gridCanvas');
const gridCtx = gridCanvas.getContext('2d');
const splineCanvas = document.getElementById('splineCanvas');
const splineCtx = splineCanvas.getContext('2d');
const characterField = document.getElementById('character');
const saveButton = document.getElementById('saveButton');
const saveDropdown = document.getElementById('saveDropdown');
const saveMode = document.getElementById('saveMode');
const clearButton = document.getElementById('clearButton');
const clearAllButton = document.getElementById('clearAllButton');
const clearAllDropdown = document.getElementById('clearAllDropdown');
const deleteButton = document.getElementById('deleteButton');
const deleteDropdown = document.getElementById('deleteDropdown');
const deleteMode = document.getElementById('deleteMode');
const freezeButton = document.getElementById('freezeButton');
const glyphsTitle = document.getElementById('glyphsTitle');
const glyphsList = document.getElementById('glyphsList');
const modesTitle = document.getElementById('modesTitle');
const modesList = document.getElementById('modesList');

const rootStyles = getComputedStyle(document.documentElement);
const colorInk = rootStyles.getPropertyValue('--ink-color').trim()
const colorSelected = rootStyles.getPropertyValue('--selected-color').trim()
const colorDarkSelected = rootStyles.getPropertyValue('--dark-selected-color').trim()
const colorFreeze = rootStyles.getPropertyValue('--freeze-color').trim()
const colorFrozen = rootStyles.getPropertyValue('--frozen-color').trim()
const colorDisabled = rootStyles.getPropertyValue('--disabled-color').trim()

let selectedPoints = [];
let selectedCharacters = [];
let numPerSelected = [];
let frozenPoints = [];
let numSplinesPerChar = [];
const gridSize = 76;
const cellSize = 20;
const centerOffset = Math.floor(gridSize / 2) * cellSize;

function drawGrid() {
    gridCtx.clearRect(0, 0, gridCanvas.width, gridCanvas.height);

    // Draw the lighter grid lines
    gridCtx.beginPath();
    gridCtx.strokeStyle = 'rgba(0, 0, 0, 0.1)'; // Very light gray
    gridCtx.lineWidth = 1; // Thin line width
    for (let i = 0; i <= gridSize; i++) {
        gridCtx.moveTo(i * cellSize, 0);
        gridCtx.lineTo(i * cellSize, gridCanvas.height);
        gridCtx.moveTo(0, i * cellSize);
        gridCtx.lineTo(gridCanvas.width, i * cellSize);
    }
    gridCtx.stroke();

    // Draw the darker center lines
    gridCtx.beginPath();
    gridCtx.strokeStyle = '#000'; // Dark color for center lines
    gridCtx.lineWidth = 1; // Thinner line width for center lines
    const centerX = centerOffset;
    const centerY = centerOffset;

    // Vertical center line
    gridCtx.moveTo(centerX, 0);
    gridCtx.lineTo(centerX, gridCanvas.height);

    // Horizontal center line
    gridCtx.moveTo(0, centerY);
    gridCtx.lineTo(gridCanvas.width, centerY);

    gridCtx.stroke();

    // Draw the dark center squares
    gridCtx.beginPath();
    gridCtx.strokeStyle = '#000';
    gridCtx.lineWidth = 1;
    gridCtx.strokeRect(centerX - 120, centerY - 120, 240, 240);
    gridCtx.strokeRect(centerX - 240, centerY - 240, 480, 480);
    gridCtx.strokeRect(centerX - 360, centerY - 360, 720, 720);
    gridCtx.strokeRect(centerX - 480, centerY - 480, 960, 960);
    gridCtx.strokeRect(centerX - 600, centerY - 600, 1200, 1200);
    gridCtx.strokeRect(centerX - 720, centerY - 720, 1440, 1440);
    gridCtx.stroke();
}

function drawPoints(points = null, color = colorSelected) {
    splineCtx.fillStyle = color; // Color for knot points
    if (!points) {
        selectedPoints.forEach(([x, y]) => {
            splineCtx.beginPath();
            splineCtx.arc(centerOffset + x * cellSize, centerOffset - y * cellSize, 5, 0, Math.PI * 2);
            splineCtx.fill();
        });
    } else {
        points.forEach(([x, y]) => {
            splineCtx.beginPath();
            splineCtx.arc(centerOffset + x * cellSize, centerOffset - y * cellSize, 5, 0, Math.PI * 2);
            splineCtx.fill();
        });
    }
}
function updatePointsField() {
    drawGrid(); // Redraw the grid
    splineCtx.clearRect(0, 0, splineCanvas.width, splineCanvas.height); // Clear spline visualization

    // Paint frozen stuff first; this is only ever a single spline
    if (frozenPoints) {
        frozenPoints.forEach((points) => {
            const shiftedPoints = points.map(([x, y]) => [(x + gridSize / 2) / gridSize, (y + gridSize / 2) / gridSize]);
            plotSpline(shiftedPoints, colorDisabled, null);
            drawPoints(points, colorDisabled); // Enforce drawing NOW so subsequent drawings will appear above it
        })
    }

    // Exit if no characters are selected
    if (selectedPoints.length === 0) return;

    // Shift all splines prior to the last one
    selectedPoints.forEach((points, splineIndex) => {
        let normalizedPoints;

        if (splineIndex < selectedPoints.length - 1) {
            // Shift all splines except the last one so that the second-to-last ends at the origin
            normalizedPoints = points.map(([x, y]) => [(x + gridSize / 2) / gridSize, (y + gridSize / 2) / gridSize]);
        } else {
            // Keep the last spline unshifted
            normalizedPoints = selectedPoints[splineIndex].map(([x, y]) => [(x + gridSize / 2) / gridSize, (y + gridSize / 2) / gridSize]);
        }

        if (normalizedPoints.length > 1){
            plotSpline(normalizedPoints, colorInk, () => {
                // Only draw points for the last spline
                if (splineIndex === selectedPoints.length - 1) {
                    drawPoints(selectedPoints[splineIndex]);
                }
            });
        } else {
            drawPoints(points, (splineIndex === selectedPoints.length-1) ? colorSelected : colorInk)
        }
    });
}

function plotSpline(points, color = colorInk, callback = null) {
    if (points.length > 1) {
        axios.post('/spline', { points })
            .then(response => {
                splineCtx.beginPath();
                splineCtx.lineWidth = 4; // Thicker line width for spline
                splineCtx.strokeStyle = color;
                splineCtx.lineCap = 'round'
                const spline = response.data.spline;
                spline.forEach(([x, y], index) => {
                    const plotX = (x + (gridSize / 2)) * (splineCanvas.width / gridSize);
                    const plotY = splineCanvas.height - ((y + (gridSize / 2)) * (splineCanvas.height / gridSize));
                    if (index === 0) {
                        splineCtx.moveTo(plotX, plotY);
                    } else {
                        splineCtx.lineTo(plotX, plotY);
                    }
                });
                splineCtx.stroke();

                // Redraw the points
                if (callback) {
                    callback();
                }
            });
    }
    // always draw the points, even if they'll get redrawn later
    // to avoid no points being drawn if there's only 1
    if (callback) {
        callback();
    }
}

gridCanvas.addEventListener('click', (event) => {

    const rect = gridCanvas.getBoundingClientRect();
    const x = event.clientX - rect.left - centerOffset;
    const y = rect.top + centerOffset - event.clientY;
    const gridX = Math.round(x / cellSize);
    const gridY = Math.round(y / cellSize);

    const isCtrlPressed = event.ctrlKey;

    if ((isCtrlPressed) || (selectedPoints.length === 0)) {  // start a new spline
        selectedPoints.push([[gridX, gridY]]);
        selectedCharacters.push('')
        numPerSelected.push(1)
    } else {
        // add point
        selectedPoints[selectedPoints.length - 1].push([gridX, gridY]);
    }

    updatePointsField();
    refreshButtons();
});

gridCanvas.addEventListener('contextmenu', (event) => {
    // For deleting points using right-click

    // Deletes the point
    event.preventDefault();  // don't open the usual right-click menu

    const rect = gridCanvas.getBoundingClientRect();
    const x = event.clientX - rect.left - centerOffset;
    const y = rect.top + centerOffset - event.clientY;
    const gridX = Math.round(x / cellSize);
    const gridY = Math.round(y / cellSize);

    const isCtrlPressed = event.ctrlKey;

    const pointIndex = selectedPoints[selectedPoints.length-1].findLastIndex(([px, py]) => Math.round(px) === gridX && Math.round(py) === gridY);
    // Ctrl+click: Remove the point if it exists
    if (pointIndex !== -1) {
        selectedPoints[selectedPoints.length-1].splice(pointIndex, 1);
        if (selectedPoints[selectedPoints.length-1].length === 0) {
            selectedPoints.pop()
            numPerSelected[numPerSelected.length - 1] -= 1
            if (numPerSelected[numPerSelected.length - 1] === 0) {
                numPerSelected.pop()
                selectedCharacters.pop()
            }
        }
    }

    updatePointsField();
    refreshButtons();
});


function handleCharSelect(char, charPoints = null, append = false) {
    if (char === null) {
        // deselect everything
        selectedPoints = []
        numPerSelected = []
        selectedCharacters = []
    }

    if (char !== null) {
        // selecting un-selected character
        const newPoints = charPoints ? charPoints : (char in charSplineData ? charSplineData[char] : [])
        // const shiftedNewPoints = newPoints.map(([x, y]) => [x * gridSize - gridSize / 2, y * gridSize - gridSize / 2]);
        const shiftedNewPoints = newPoints.map(spline =>
            spline.map(([x, y]) => [(x * gridSize  - gridSize / 2), (y * gridSize - gridSize / 2)])
            );

        if (!append) {
            const numToRemove = numPerSelected.pop()
            selectedPoints.splice(-numToRemove, numToRemove)
            selectedCharacters.pop()
        }

        let shiftedAppendPoints = shiftedNewPoints
        if ((selectedPoints.length > 0) && (selectedPoints[selectedPoints.length - 1].length > 0)) {
            // shift by last point
            const lastSpline = selectedPoints[selectedPoints.length - 1]
            const lastPoint = lastSpline[lastSpline.length - 1]
            const firstPoint = shiftedAppendPoints[0][0]
            shiftedAppendPoints = shiftedAppendPoints.map(spline =>
                spline.map(([x, y]) => [x - firstPoint[0] + lastPoint[0], y - firstPoint[1] + lastPoint[1]])
                );
        }

        selectedPoints = selectedPoints.concat(shiftedAppendPoints)

        selectedCharacters.push(char)
        numPerSelected.push(numSplinesPerChar[char])
    } else {  // not allowed to multi-select characters

    }
}

function refreshButtons() {
    refreshDeleteButton();
    refreshFreezeButton();
    refreshSaveButton();
    refreshClearAllButton();

    // update coloring of spline list
    document.querySelectorAll('.char-list-item').forEach(item => {
        item.classList.remove('selected');
        item.classList.remove('joining');

        if (selectedCharacters.includes(item.textContent)) {
            if (item.textContent === selectedCharacters[selectedCharacters.length - 1]) {
                // most recently-selected glyph
                item.classList.add('selected');
            } else {
                // preceding glyph
                item.classList.add('joining');
            }
        }
    });

    // update coloring of spline list
    document.querySelectorAll('.char-list-item').forEach(item => {
        item.classList.remove('selected');
        item.classList.remove('joining');

        if (selectedCharacters.includes(item.textContent)) {
            if (item.textContent === selectedCharacters[selectedCharacters.length - 1]) {
                // most recently-selected glyph
                item.classList.add('selected');
            } else {
                // preceding glyph
                item.classList.add('joining');
            }
        }
    });
}

function refreshSaveButton() {
    // can't do things if no points selected, or character of selected points is not specified
    saveButton.disabled = (selectedPoints.length === 0) || (characterField.value === '')
    saveDropdown.disabled = saveButton.disabled

    const noneSelected = (selectedPoints.length === 0) || (selectedPoints[selectedPoints.length - 1].length === 0)
    clearButton.disabled = noneSelected
}

function refreshClearAllButton() {
    clearAllButton.disabled = (selectedPoints.length === 0) || (selectedPoints[selectedPoints.length - 1].length === 0)
    clearAllDropdown.disabled = clearAllButton.disabled
    // clearAllDropdown.display = clearAllDropdown.disabled ? 'none' : 'block'
    // clearAllButton.display = clearAllButton.disabled ? 'none' : 'block'
}

function refreshFreezeButton() {
    freezeButton.disabled = (frozenPoints.length === 0) && ((selectedPoints.length === 0) || (selectedPoints[selectedPoints.length - 1].length === 0))
}

function refreshDeleteButton() {
    deleteButton.disabled = (selectedPoints.length === 0)

    if (deleteButton.disabled) {
        if (deleteButton.classList.contains('delete-button')) {
            deleteButton.classList.remove('delete-button')
        }
    } else {
        if (!deleteButton.classList.contains('delete-button')) {
            // deleteButton.classList.add('delete-button')
        }
    }

    deleteDropdown.disabled = deleteButton.disabled
}

function scrollIfNeeded(item) {
    // Smarter scrollIntoView which accounts for the size of the item and its parent
    const rect = item.getBoundingClientRect();
    const parentRect = item.parentNode.getBoundingClientRect();

    // Check if item is fully visible within its parent
    const isFullyVisible = rect.top >= parentRect.top && rect.bottom <= parentRect.bottom;

    // Scroll into view only if the item is not fully visible
    if (!isFullyVisible) {
        item.scrollIntoView({ behavior: 'smooth', block: 'start' });
    }
}

function loadCharacters() {
    axios.get('/load_characters')
        .then(response => {

            charSplineData = response.data; // Store the data in the global variable
            glyphsList.innerHTML = '';
            glyphsTitle.textContent = 'Glyphs (' + Object.keys(charSplineData).length + ')'

            for (const [character, points] of Object.entries(charSplineData)) {
                numSplinesPerChar[character] = points.length  // used during de-selection

                const listItem = document.createElement('div');
                listItem.className = 'char-list-item';
                listItem.textContent = character;

                listItem.addEventListener('click', (event) => {
                    characterField.focus()
                    characterField.value = ''
                    handleCharSelect(character, null, event.ctrlKey)
                    refreshButtons();
                    updatePointsField();
                });
                glyphsList.appendChild(listItem);
            }
        });
}

function loadModes() {
    axios.get('/load_modes')
        .then(response => {

            modeSplineData = response.data; // Store the data in the global variable
            modesList.innerHTML = '';
            modesTitle.textContent = 'Modes (' + Object.keys(modeSplineData).length + ')'

            for (const [mode, points] of Object.entries(modeSplineData)) {
                numSplinesPerChar[mode] = points.length  // used during de-selection

                const listItem = document.createElement('div');
                listItem.className = 'char-list-item';
                listItem.textContent = mode;

                listItem.addEventListener('click', (event) => {
                    characterField.focus()
                    characterField.value = ''
                    handleCharSelect(mode, points)
                    refreshButtons();
                    updatePointsField();
                });
                modesList.appendChild(listItem);
            }
        });
}


saveButton.addEventListener('click', () => {
    if (selectedPoints.length) {

        const data = {
            character: characterField.value.trim(),
            points: selectedPoints.map(spline =>
                spline.map(([x, y]) => [(x + gridSize / 2) / gridSize, (y + gridSize / 2) / gridSize])
                ),
            as_mode: false,
            // dots: dots.map(([x, y]) => [(x + gridSize / 2) / gridSize, (y + gridSize / 2) / gridSize]),
        };
        axios.post('/save', data)
            .then(response => {
                if (response.data.status === 'success') {
                    loadCharacters();
                    handleCharSelect(null);
                    refreshButtons();
                    updatePointsField();
                    characterField.value = '';
                    characterField.focus();
                }
            });
    }

});

saveMode.addEventListener('click', () => {
    if (selectedPoints.length) {

        const data = {
            character: characterField.value.trim(),
            points: selectedPoints.map(spline =>
                spline.map(([x, y]) => [(x + gridSize / 2) / gridSize, (y + gridSize / 2) / gridSize])
                ),
            as_mode: true,
        };
        axios.post('/save', data)
            .then(response => {
                if (response.data.status === 'success') {
                    loadModes();
                    handleCharSelect(null);
                    refreshButtons();
                    updatePointsField();
                    characterField.value = '';
                    characterField.focus();
                }
            });
    }
});

clearButton.addEventListener('click', () => {
    selectedPoints.pop()
    numPerSelected[numPerSelected.length - 1] -= 1

    if (numPerSelected[numPerSelected.length - 1] === 0) {
        selectedCharacters.pop()
        numPerSelected.pop()
    }
    updatePointsField();
    refreshButtons();
});

deleteButton.addEventListener('click', () => {
    if (selectedPoints) {
        axios.post('/delete', { character: characterField.value.trim(), as_mode: false})
            .then(response => {
                if (response.data.status === 'success') {
                    loadCharacters();
                    handleCharSelect(null);
                    refreshButtons();
                    updatePointsField();
                    characterField.value = '';
                    characterField.focus();
                }
            });
    }
});

deleteMode.addEventListener('click', () => {
    if (selectedPoints) {
        axios.post('/delete', { character: characterField.value.trim(), as_mode: true})
            .then(response => {
                if (response.data.status === 'success') {
                    loadModes();
                    handleCharSelect(null);
                    refreshButtons();
                    updatePointsField();
                    characterField.value = '';
                    characterField.focus();
                }
            });
    }
});

freezeButton.addEventListener('click', () => {
    splineCtx.clearRect(0, 0, splineCanvas.width, splineCanvas.height);

    if (freezeButton.textContent === 'Freeze') { // freeze
        frozenPoints = selectedPoints

        clearAllButton.click()
        refreshButtons();

    } else {  // unfreeze
        frozenPoints = [];
        refreshFreezeButton();
    }

    freezeButton.textContent = (freezeButton.textContent === 'Freeze') ? 'Unfreeze' : 'Freeze';
    updatePointsField();
    characterField.focus();
});

// Click event listener
clearAllButton.addEventListener('click', (e) => {
    // Clear the points, characters, and other data
    selectedPoints = [];
    numPerSelected = [];
    selectedCharacters = [];

    // Refresh coloring of spline list
    document.querySelectorAll('.char-list-item').forEach(item => {
        item.classList.remove('selected');
        item.classList.remove('joining');
    });

    // Update the input field and focus
    characterField.value = '';
    characterField.focus();

    // Update fields and buttons
    updatePointsField();
    refreshButtons();

    // Forcefully close the dropdown by removing the 'show' class
    const dropdown = document.querySelector('.dropdown-menu');
    dropdown.classList.remove('show');
    document.getElementById('clearAllDropdown').setAttribute('aria-expanded', 'false');

    // Prevent the default anchor behavior
    e.preventDefault();
});


// to avoid too-fast updates when typing into char field
let debounceTimeout;
function debounce(func, delay) {
    return function(...args) {
        clearTimeout(debounceTimeout);
        debounceTimeout = setTimeout(() => func.apply(this, args), delay);
    };
}

// Debounce the plot update to avoid too many requests
const debouncedKeyCheck = debounce(keyCheck, 100);  // ms?

function keyCheck(event) {
    // handling typing in the character field,
    // and listening for Ctrl, Shift or Esc clicks
    // if (event.key === 'Control') {
    //     freezeButton.click()
    // } else if (event.key === 'Shift') {
    //     // joinButton.click();
    // } else if (event.key == 'Escape') {
    //     clearButton.click()
    // }
    // else {
        sortAndDisplayList();
    // }
}

// Bind the input event on textarea and change event on checkboxes
characterField.addEventListener('keyup', function(event) {
    debouncedKeyCheck(event);
    refreshButtons();
})

function sortAndDisplayList() {
    sortOneList(glyphsList);
    glyphsList.scrollTop = glyphsList.scrollHeight

    sortOneList(modesList);
    modesList.scrollTop = modesList.scrollHeight
}

function sortOneList(listToSort) {
    // Get the value from the character input field
    const searchTerm = document.getElementById('character').value.toLowerCase();

    // Get current list items
    let listItems = Array.from(listToSort.children);

    // Function to check if an item contains the search term
    const containsSearchTerm = text => text.toLowerCase().includes(searchTerm);
    const startsWithSearchTerm = text => text.toLowerCase().startsWith(searchTerm);

    // Separate items into those that start with the search term, those that contain it elsewhere, and those that do not contain it
    let startsWithItems = listItems.filter(item => startsWithSearchTerm(item.textContent));
    let containsItems = listItems.filter(item => containsSearchTerm(item.textContent) && !startsWithSearchTerm(item.textContent));
    let nonMatchingItems = listItems.filter(item => !containsSearchTerm(item.textContent));

    // Sort each array alphabetically
    startsWithItems.sort((a, b) => a.textContent.toLowerCase().localeCompare(b.textContent.toLowerCase()));
    containsItems.sort((a, b) => a.textContent.toLowerCase().localeCompare(b.textContent.toLowerCase()));
    nonMatchingItems.sort((a, b) => a.textContent.toLowerCase().localeCompare(b.textContent.toLowerCase()));

    // Combine the arrays: items starting with the search term first, then items containing it elsewhere, then non-matching items
    let sortedItems = startsWithItems.concat(containsItems, nonMatchingItems);

    // Clear the current list and re-append sorted items
    listToSort.innerHTML = '';
    sortedItems.slice().reverse().forEach(item => {
        listToSort.appendChild(item);
    });
}

refreshButtons();
drawGrid();
loadCharacters();
loadModes();

document.addEventListener("DOMContentLoaded", function() {
    const gridContainer = document.querySelector('.grid-container');
    const containerWidth = gridContainer.clientWidth;
    const containerHeight = gridContainer.clientHeight;
    const gridWidth = 1520;
    const gridHeight = 1520;

    gridContainer.scrollLeft = (gridWidth - containerWidth) / 2;
    gridContainer.scrollTop = (gridHeight - containerHeight) / 2;
});

characterField.focus();
</script>
{% endblock %}
