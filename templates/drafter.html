{% extends "index.html" %}

{% block content %}
<div class="main-content">
    <div class="controls">
        <div class="d-flex flex-row" style="margin:5px;">
            <div class="d-flex flex-column flex-grow-1">
                <h2>Glyphs</h2>
                <input type="text" id="character" placeholder="Enter character(s)" autocomplete="off">
                <div id="glyphsList" class="spline-list" style="margin-right: 5px;"></div>
            </div>
        </div>
        <div class="d-flex flex-column">
            <button id="deleteButton" type="button" class="btn btn-danger" disabled>Delete</button>
            <div class="d-flex justify-content-between">
                    <div class="btn-group">
                        <button id="saveButton" type="button" class="btn btn-primary">Save</button>
                        <button id="saveDropdown" type="button" class="btn btn-primary dropdown-toggle dropdown-toggle-split" data-bs-toggle="dropdown" aria-expanded="false">
                            <span class="visually-hidden">Toggle Dropdown</span>
                        </button>
                        <ul class="dropdown-menu">
                            <li><a id="saveWord" class="dropdown-item" href="#" id="saveAsOption">as word</a></li>
                        </ul>
                    </div>
                    <button id="clearButton" type="button" class="btn btn-primary" disabled>Clear</button>
                    <!-- <button id="joinButton" type="button" class="btn btn-primary" disabled>Join</button> -->
                    <!-- <button id="unjoinButton" type="button" class="btn btn-primary" disabled>Unjoin</button> -->
                    <button id="freezeButton" type="button" class="btn btn-primary" disabled>Freeze</button>
                    <button id="deselectButton" type="button" class="btn btn-primary" disabled>Deselect All</button>
            </div>
        </div>
    </div>
    <div class="grid-container">
        <canvas id="splineCanvas" width="1520" height="1520"></canvas>
        <canvas id="gridCanvas" width="1520" height="1520"></canvas>
    </div>
</div>
<script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
<script>
let charSplineData = {}; // Global variable to store spline data
let dotsData = {}; // Global variable to store spline data
const gridCanvas = document.getElementById('gridCanvas');
const gridCtx = gridCanvas.getContext('2d');
const splineCanvas = document.getElementById('splineCanvas');
const splineCtx = splineCanvas.getContext('2d');
const characterField = document.getElementById('character');
const saveButton = document.getElementById('saveButton');
const saveDropdown = document.getElementById('saveDropdown');
const saveWord = document.getElementById('saveWord');
const clearButton = document.getElementById('clearButton');
const deleteButton = document.getElementById('deleteButton');
// const joinButton = document.getElementById('joinButton');
// const unjoinButton = document.getElementById('unjoinButton');
const freezeButton = document.getElementById('freezeButton');
const deselectButton = document.getElementById('deselectButton');
const glyphsList = document.getElementById('glyphsList');

const rootStyles = getComputedStyle(document.documentElement);
const colorInk = rootStyles.getPropertyValue('--ink-color').trim()
const colorSelected = rootStyles.getPropertyValue('--selected-color').trim()
const colorDarkSelected = rootStyles.getPropertyValue('--dark-selected-color').trim()
const colorFreeze = rootStyles.getPropertyValue('--freeze-color').trim()
const colorFrozen = rootStyles.getPropertyValue('--frozen-color').trim()
const colorDisabled = rootStyles.getPropertyValue('--disabled-color').trim()

let selectedPoints = [];
let frozenPoints = [];
let dots = [];
let selectedCharacters = [];
let numSplinesPerChar = [];
const gridSize = 76;
const cellSize = 20;
const centerOffset = Math.floor(gridSize / 2) * cellSize;

function drawGrid() {
    gridCtx.clearRect(0, 0, gridCanvas.width, gridCanvas.height);

    // Draw the lighter grid lines
    gridCtx.beginPath();
    gridCtx.strokeStyle = 'rgba(0, 0, 0, 0.1)'; // Very light gray
    gridCtx.lineWidth = 1; // Thin line width
    for (let i = 0; i <= gridSize; i++) {
        gridCtx.moveTo(i * cellSize, 0);
        gridCtx.lineTo(i * cellSize, gridCanvas.height);
        gridCtx.moveTo(0, i * cellSize);
        gridCtx.lineTo(gridCanvas.width, i * cellSize);
    }
    gridCtx.stroke();

    // Draw the darker center lines
    gridCtx.beginPath();
    gridCtx.strokeStyle = '#000'; // Dark color for center lines
    gridCtx.lineWidth = 1; // Thinner line width for center lines
    const centerX = centerOffset;
    const centerY = centerOffset;

    // Vertical center line
    gridCtx.moveTo(centerX, 0);
    gridCtx.lineTo(centerX, gridCanvas.height);

    // Horizontal center line
    gridCtx.moveTo(0, centerY);
    gridCtx.lineTo(gridCanvas.width, centerY);

    gridCtx.stroke();

    // Draw the dark center squares
    gridCtx.beginPath();
    gridCtx.strokeStyle = '#000';
    gridCtx.lineWidth = 1;
    gridCtx.strokeRect(centerX - 120, centerY - 120, 240, 240);
    gridCtx.strokeRect(centerX - 240, centerY - 240, 480, 480);
    gridCtx.strokeRect(centerX - 360, centerY - 360, 720, 720);
    gridCtx.strokeRect(centerX - 480, centerY - 480, 960, 960);
    gridCtx.strokeRect(centerX - 600, centerY - 600, 1200, 1200);
    gridCtx.strokeRect(centerX - 720, centerY - 720, 1440, 1440);
    gridCtx.stroke();
}

function drawPoints(points = null, color = colorSelected) {
    splineCtx.fillStyle = color; // Color for knot points
    if (!points) {
        selectedPoints.forEach(([x, y]) => {
            splineCtx.beginPath();
            splineCtx.arc(centerOffset + x * cellSize, centerOffset - y * cellSize, 5, 0, Math.PI * 2);
            splineCtx.fill();
        });
    } else {
        points.forEach(([x, y]) => {
            splineCtx.beginPath();
            splineCtx.arc(centerOffset + x * cellSize, centerOffset - y * cellSize, 5, 0, Math.PI * 2);
            splineCtx.fill();
        });
    }
}

function updatePointsField() {
    drawGrid(); // Redraw the grid
    splineCtx.clearRect(0, 0, splineCanvas.width, splineCanvas.height); // Clear spline visualization

    // paint frozen stuff first; this is only ever a single spline
    if (frozenPoints) {
        const shiftedPoints = frozenPoints.map(([x, y]) => [(x + gridSize / 2) / gridSize, (y + gridSize / 2) / gridSize]);
        plotSpline(shiftedPoints, colorDisabled, null);
        drawPoints(frozenPoints, colorDisabled)  // to enforce that it's drawn NOW, that way the next drawings will be above it
    }

    // now paint the other stuff
    if (selectedCharacters.length === 0) return;

    let lastEndPoint = null;
    let splinesToPlot = [];

    // Iterate over each spline (list of points)
    selectedPoints.forEach((points) => {
        // Shift the current spline by the last point of the previous spline
        let shiftedPoints = lastEndPoint 
            ? points.map(([x, y]) => [x + lastEndPoint[0] - points[0][0], y + lastEndPoint[1] - points[0][1]])
            : points;

        splinesToPlot.push(shiftedPoints);
        lastEndPoint = shiftedPoints[shiftedPoints.length - 1]; // Update lastEndPoint to the last point of current spline
    });

    
    let diff = [0, 0]
    if (selectedPoints[selectedPoints.length - 1].length > 0) {
        // in case the points have been cleared and are now empty
        const [lastX, lastY] = splinesToPlot[splinesToPlot.length - 1][0]; // First point of the last spline
        diff = [selectedPoints[selectedPoints.length - 1][0][0] - lastX, selectedPoints[selectedPoints.length - 1][0][1] - lastY];
    }

    splinesToPlot.forEach((points, splineIndex) => {
        // Shift all splines such that the last spline starts at its original position
        const normalizedPoints = points.map(([x, y]) => [(x + diff[0] + gridSize / 2) / gridSize, (y + diff[1] + gridSize / 2) / gridSize]);

        plotSpline(normalizedPoints, colorInk, () => {
            // Only draw points for the last spline
            if (splineIndex === splinesToPlot.length - 1) {
                drawPoints(selectedPoints[splineIndex]);
            }
        });
    });
}


function plotSpline(points, color = colorInk, callback = null) {
    if (points.length > 1) {
        axios.post('/spline', { points })
            .then(response => {
                splineCtx.beginPath();
                splineCtx.lineWidth = 4; // Thicker line width for spline
                splineCtx.strokeStyle = color;
                splineCtx.lineCap = 'round'
                const spline = response.data.spline;
                spline.forEach(([x, y], index) => {
                    const plotX = (x + (gridSize / 2)) * (splineCanvas.width / gridSize);
                    const plotY = splineCanvas.height - ((y + (gridSize / 2)) * (splineCanvas.height / gridSize));
                    if (index === 0) {
                        splineCtx.moveTo(plotX, plotY);
                    } else {
                        splineCtx.lineTo(plotX, plotY);
                    }
                });
                splineCtx.stroke();

                // Redraw the points
                if (callback) {
                    callback();
                }
            });
    }
    // always draw the points, even if they'll get redrawn later
    // to avoid no points being drawn if there's only 1
    if (callback) {
        callback();
    }
}

gridCanvas.addEventListener('click', (event) => {

    const rect = gridCanvas.getBoundingClientRect();
    const x = event.clientX - rect.left - centerOffset;
    const y = rect.top + centerOffset - event.clientY;
    const gridX = Math.round(x / cellSize);
    const gridY = Math.round(y / cellSize);

    const isCtrlPressed = event.ctrlKey;

    if (isCtrlPressed) {  // remove point
        dots.push([gridX, gridY]);
    } else {
        // add point
        selectedPoints[selectedPoints.length - 1].push([gridX, gridY]);
    }

    updatePointsField();
    refreshSaveButton();
});

gridCanvas.addEventListener('contextmenu', (event) => {
    // For deleting points using right-click

    // Deletes the point
    event.preventDefault();  // don't open the usual right-click menu

    const rect = gridCanvas.getBoundingClientRect();
    const x = event.clientX - rect.left - centerOffset;
    const y = rect.top + centerOffset - event.clientY;
    const gridX = Math.round(x / cellSize);
    const gridY = Math.round(y / cellSize);

    const isCtrlPressed = event.ctrlKey;

    if (isCtrlPressed) {  // remove from dots
        const pointIndex = dots.findLastIndex(([px, py]) => Math.round(px) === gridX && Math.round(py) === gridY);
        // Ctrl+click: Remove the point if it exists
        if (pointIndex !== -1) {
            dots.splice(pointIndex, 1);
        }
    } else {  // add dot
        const pointIndex = selectedPoints[selectedPoints.length-1].findLastIndex(([px, py]) => Math.round(px) === gridX && Math.round(py) === gridY);
        // Ctrl+click: Remove the point if it exists
        if (pointIndex !== -1) {
            selectedPoints[selectedPoints.length-1].splice(pointIndex, 1);
        }
    }

    updatePointsField();
    refreshSaveButton();
});


function handleCharSelect(char, points = null, newDots = null, append = false) {
    if (char === null) {
        // deselect everything
        selectedCharacters = []
        selectedPoints = []
    }

    if (char === selectedCharacters[selectedCharacters.length - 1]) {
        // de-selecting most recent character
        const popped = selectedCharacters.pop()
        selectedPoints.splice(-numSplinesPerChar[popped], numSplinesPerChar[popped])
    } else if ((char !== null) && (!selectedCharacters.includes(char))) {
        // selecting un-selected character
        const newPoints = points ? points : (char in charSplineData ? charSplineData[char] : [])
        // const shiftedNewPoints = newPoints.map(([x, y]) => [x * gridSize - gridSize / 2, y * gridSize - gridSize / 2]);
        const shiftedNewPoints = newPoints.map(spline => 
            spline.map(([x, y]) => [(x * gridSize  - gridSize / 2), (y * gridSize - gridSize / 2)])
            );

        if (append) {
            selectedCharacters.push(char)

            selectedPoints = selectedPoints.concat(shiftedNewPoints)
        } else { // overwrite most recent with new
            const popped = selectedCharacters.pop()
            selectedCharacters.push(char)

            selectedPoints.splice(-numSplinesPerChar[popped], numSplinesPerChar[popped])
            selectedPoints = selectedPoints.concat(shiftedNewPoints)
        }
    } else {  // not allowed to multi-select characters

    }

    // update plotting points
    const mostRecent = selectedCharacters[selectedCharacters.length - 1]

    // dots = newDots ? newDots : (char in dotsData) ? dotsData[char] : []
    // dots = dots.map(([x, y]) => [x * gridSize - gridSize / 2, y * gridSize - gridSize / 2]);

    characterField.value = mostRecent ? mostRecent : '';
    // characterField.focus();

    // update coloring of spline list
    document.querySelectorAll('.char-list-item').forEach(item => {
        item.classList.remove('selected');
        item.classList.remove('joining');

        if (selectedCharacters.includes(item.textContent)) {
            if (item.textContent === mostRecent) {
                item.classList.add('selected');
                // item.scrollIntoView({ behavior: 'smooth', block: 'start' });
                scrollIfNeeded(item);
            } else {
                item.classList.add('joining');
            }
        }
    });
}

function refreshButtons() {
    refreshDeleteButton();
    refreshFreezeButton();
    refreshSaveButton();
    refreshDeselectButton();
}

function refreshSaveButton() {
    const anySelected = (selectedPoints.length === 0) && (dots.length === 0)
    saveButton.disabled = anySelected
    saveDropdown.disabled = anySelected
    clearButton.disabled = anySelected
}

function refreshDeselectButton() {
    deselectButton.disabled = selectedCharacters.length === 0
}

function refreshFreezeButton() {
    freezeButton.disabled = (frozenPoints.length === 0) && (selectedCharacters.length === 0)
}

function refreshDeleteButton() {
    deleteButton.disabled = (selectedCharacters.length === 0)
    if (deleteButton.disabled) {
        if (deleteButton.classList.contains('delete-button')) {
            deleteButton.classList.remove('delete-button')
        }
    } else {
        if (!deleteButton.classList.contains('delete-button')) {
            // deleteButton.classList.add('delete-button')
        }
    }
}

function scrollIfNeeded(item) {
    // Smarter scrollIntoView which accounts for the size of the item and its parent
    const rect = item.getBoundingClientRect();
    const parentRect = item.parentNode.getBoundingClientRect();

    // Check if item is fully visible within its parent
    const isFullyVisible = rect.top >= parentRect.top && rect.bottom <= parentRect.bottom;

    // Scroll into view only if the item is not fully visible
    if (!isFullyVisible) {
        item.scrollIntoView({ behavior: 'smooth', block: 'start' });
    }
}

function loadCharacters() {
    axios.get('/load_characters')
        .then(response => {

            charSplineData = response.data; // Store the data in the global variable
            glyphsList.innerHTML = '';

            for (const [character, points] of Object.entries(charSplineData)) {
                numSplinesPerChar[character] = points.length  // used during de-selection

                const listItem = document.createElement('div');
                listItem.className = 'char-list-item';
                listItem.textContent = character;

                listItem.addEventListener('click', (event) => {
                    handleCharSelect(character, null, null, event.ctrlKey)
                    refreshButtons();
                    updatePointsField();
                });
                glyphsList.appendChild(listItem);
            }
        });
    loadDots();
}

saveButton.addEventListener('click', () => {
    if (selectedCharacters.length && selectedPoints.length) {
        const data = {
            character: selectedCharacters.join(''),
            points: selectedPoints.map(spline => 
                spline.map(([x, y]) => [(x + gridSize / 2) / gridSize, (y + gridSize / 2) / gridSize])
                ),
            // as_word: false,
            // dots: dots.map(([x, y]) => [(x + gridSize / 2) / gridSize, (y + gridSize / 2) / gridSize]),
        };
        axios.post('/save', data)
            .then(response => {
                if (response.data.status === 'success') {
                    loadCharacters();
                    handleCharSelect(null);
                    refreshButtons();
                    updatePointsField();
                    characterField.value = '';
                    characterField.focus();
                }
            });
    }

});

saveWord.addEventListener('click', () => {
    let combinedArray = [...selectedPoints];

    const character = characterField.value.trim();
    if (character && combinedArray.length) {
        const data = {
            character: character,
            points: combinedArray.map(([x, y]) => [(x + gridSize / 2) / gridSize, (y + gridSize / 2) / gridSize]),
            as_word: true,
        };
        axios.post('/save', data)
            .then(response => {
                if (response.data.status === 'success') {
                    loadCharacters();
                    handleCharSelect(null);
                    refreshButtons();
                    updatePointsField();
                    characterField.value = '';
                    characterField.focus();
                }
            });
    }

});

clearButton.addEventListener('click', () => {
    selectedPoints[selectedPoints.length-1] = [];
    // dots = [];
    updatePointsField();
    refreshSaveButton();
});

deleteButton.addEventListener('click', () => {
    if (selectedCharacters) {
        axios.post('/delete', { character: selectedCharacters.join('')})
            .then(response => {
                if (response.data.status === 'success') {
                    loadCharacters();
                    handleCharSelect(null);
                    refreshButtons();
                    updatePointsField();
                    characterField.value = '';
                    characterField.focus();
                }
            });
    }
});

function loadDots() {
    axios.get('/load_dots')
        .then(response => {
            dotsData = response.data['chars']; // Store the data in the global variable
        });
}

// joinButton.addEventListener('click', () => {
//     // TODO: set a "joining" flag to true, so that the next selected char is added to the list

//     if (selectedCharacters) {
//         selectedCharacters.push()
//     }

//     refreshButtons();
//     updatePointsField();

//     characterField.focus();
// });

// unjoinButton.addEventListener('click', () => {
//     selectedCharacters.pop()

//     refreshButtons();
//     updatePointsField();

//     characterField.focus();
// });

freezeButton.addEventListener('click', () => {
    splineCtx.clearRect(0, 0, splineCanvas.width, splineCanvas.height);
    
    if (freezeButton.textContent === 'Freeze') { // freeze
        // only freeze last spline
        frozenPoints = selectedPoints[selectedPoints.length-1];

        handleCharSelect(null);
        refreshButtons();
        
    } else {  // unfreeze
        frozenPoints = [];
        refreshFreezeButton();
    }

    freezeButton.textContent = (freezeButton.textContent === 'Freeze') ? 'Unfreeze' : 'Freeze';
    updatePointsField();
    characterField.focus();
});

deselectButton.addEventListener('click', () => {
    selectedCharacters = []
    selectedPoints = []

    // refresh coloring of spline list
    document.querySelectorAll('.char-list-item').forEach(item => {
        item.classList.remove('selected');
        item.classList.remove('joining');
    });

    characterField.value = '';
    characterField.focus();
    updatePointsField();
    refreshButtons();
});

// to avoid too-fast updates when typing into char field
let debounceTimeout;
function debounce(func, delay) {
    return function(...args) {
        clearTimeout(debounceTimeout);
        debounceTimeout = setTimeout(() => func.apply(this, args), delay);
    };
}

// Debounce the plot update to avoid too many requests
const debouncedKeyCheck = debounce(keyCheck, 100);  // ms?

function keyCheck(event) {
    // handling typing in the character field,
    // and listening for Ctrl, Shift or Esc clicks
    // if (event.key === 'Control') {
    //     freezeButton.click()
    // } else if (event.key === 'Shift') {
    //     // joinButton.click();
    // } else if (event.key == 'Escape') {
    //     clearButton.click()
    // }
    // else {
        sortAndDisplayList();
    // }
}

// Bind the input event on textarea and change event on checkboxes
characterField.addEventListener('keyup', function(event) {
    debouncedKeyCheck(event);
})

function sortAndDisplayList() {
    sortOneList(glyphsList);

    // item.scrollIntoView({ behavior: 'smooth', block: 'start' });
    // scrollIfNeeded(item);
    glyphsList.scrollTop = 0

    // // select the top result if it exists
    // const searchTerm = document.getElementById('character').value.toLowerCase();

    // if ((searchTerm) && (searchTerm in charSplineData)) {  // select
    //     const topResult = glyphsList.children[0];
    //     handleCharSelect(topResult.textContent)
    //     topResult.classList.add('selected');
    // } else if (searchTerm === '') {
    //     // deselect
    //     handleCharSelect(null)
    // }

    // refreshButtons();
    // updatePointsField();
}

function sortOneList(listToSort) {
    // Get the value from the character input field
    const searchTerm = document.getElementById('character').value.toLowerCase();

    // Get current list items
    let listItems = Array.from(listToSort.children);

    // Function to check if an item contains the search term
    const containsSearchTerm = text => text.toLowerCase().includes(searchTerm);
    const startsWithSearchTerm = text => text.toLowerCase().startsWith(searchTerm);

    // Separate items into those that start with the search term, those that contain it elsewhere, and those that do not contain it
    let startsWithItems = listItems.filter(item => startsWithSearchTerm(item.textContent));
    let containsItems = listItems.filter(item => containsSearchTerm(item.textContent) && !startsWithSearchTerm(item.textContent));
    let nonMatchingItems = listItems.filter(item => !containsSearchTerm(item.textContent));

    // Sort each array alphabetically
    startsWithItems.sort((a, b) => a.textContent.toLowerCase().localeCompare(b.textContent.toLowerCase()));
    containsItems.sort((a, b) => a.textContent.toLowerCase().localeCompare(b.textContent.toLowerCase()));
    nonMatchingItems.sort((a, b) => a.textContent.toLowerCase().localeCompare(b.textContent.toLowerCase()));

    // Combine the arrays: items starting with the search term first, then items containing it elsewhere, then non-matching items
    let sortedItems = startsWithItems.concat(containsItems, nonMatchingItems);

    // Clear the current list and re-append sorted items
    listToSort.innerHTML = '';
    sortedItems.forEach(item => {
        listToSort.appendChild(item);
    });
}

refreshButtons();
drawGrid();
loadCharacters();

document.addEventListener("DOMContentLoaded", function() {
    const gridContainer = document.querySelector('.grid-container');
    const containerWidth = gridContainer.clientWidth;
    const containerHeight = gridContainer.clientHeight;
    const gridWidth = 1520;
    const gridHeight = 1520;

    gridContainer.scrollLeft = (gridWidth - containerWidth) / 2;
    gridContainer.scrollTop = (gridHeight - containerHeight) / 2;
});

characterField.focus();
</script>
{% endblock %}
