{% extends "index.html" %}

{% block title %}
<title>abbrv: write</title>
{% endblock %}

{% block content %}
<form id="text-form" class="d-flex flex-column justify-content-start">
    <textarea id="text" name="text" class="form-control mb-3" placeholder="Enter text here..."></textarea>

    <div id="output"></div>

    <!-- Dropdown Menu -->
    <div class="d-flex mt-3 flex-row justify-content-between">
        <div class="d-flex flex-row">
            <!-- Options Dropdown -->
            <div class="dropdown me-3">
                <button class="btn btn-primary dropdown-toggle" type="button" id="multiSelectDropdown" data-bs-toggle="dropdown" aria-expanded="false">
                    Options
                </button>
                <ul class="dropdown-menu" aria-labelledby="dropdownMenuButton">
                    <li class="dropdown-item button-container align-items-center">
                        <input type="checkbox" id="abbrv_words" name="abbrv_words" style="max-height: 20px; max-width: 20px; min-width: 20px" checked>
                        <label for="abbrv_words" style="flex: 6;">Use word abbreviations</label>
                    </li>
                    <li class="dropdown-item button-container align-items-center">
                        <input type="checkbox" id="show_baselines" name="show_baselines" style="max-height: 20px; max-width: 20px; min-width: 20px" checked>
                        <label for="show_baselines" style="flex: 6;">Show baselines</label>
                    </li>
                    <li class="dropdown-item button-container align-items-center">
                        <input type="checkbox" id="show_dots" name="show_dots" style="max-height: 20px; max-width: 20px; min-width: 20px">
                        <label for="show_dots" style="flex: 6;">Show dots</label>
                    </li>
                    <li class="dropdown-item button-container align-items-center">
                        <input type="checkbox" id="show_knot_points" name="show_knot_points" style="max-height: 20px; max-width: 20px; min-width: 20px">
                        <label for="show_knot_points" style="flex: 6;">Display knot points</label>
                    </li>
                </ul>
            </div>

            <!-- Multi-Select Dropdown -->
            <div class="dropdown me-3">
                <button class="btn btn-primary dropdown-toggle" type="button" id="modesDropdown" data-bs-toggle="dropdown" aria-expanded="false">
                    Modes
                </button>
                <ul class="dropdown-menu" aria-labelledby="modesDropdown" id="modesDropdownItems">
                    <!-- Dropdown items will be inserted here by JavaScript -->
                </ul>
            </div>

            <!-- Multi-Select Dropdown -->
            <div class="dropdown me-3" id="rulesDropdown">
                <button class="btn btn-primary dropdown-toggle" type="button" id="rulesDropdown" data-bs-toggle="dropdown" aria-expanded="false">
                    Rules
                </button>
                <ul class="dropdown-menu" aria-labelledby="rulesDropdown" id="rulesDropdownItems">
                    <!-- Dropdown items will be inserted here by JavaScript -->
                </ul>
            </div>
        <button id="downloadButton" class="btn btn-primary">
            <i class="bi bi-download"></i>
        </button>
    </div>

</form>
{% endblock %}

{% block scripts %}
<script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
<script>
    $(document).ready(function() {
        // Function to download the SVG (same as before)
        function downloadSVG() {
            const svgElement = document.getElementById('output').innerHTML;
            const blob = new Blob([svgElement], { type: 'image/svg+xml' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'image.svg';
            document.body.appendChild(a);
            a.click();
            URL.revokeObjectURL(url);
            document.body.removeChild(a);
        }

        document.getElementById('downloadButton').addEventListener('click', downloadSVG);

        // Function to escape special characters for HTML
        function escapeHtml(unsafe) {
            return unsafe
                .replace(/&/g, "&amp;")   // Escape ampersand
                .replace(/</g, "&lt;")    // Escape less-than
                .replace(/>/g, "&gt;")     // Escape greater-than
                .replace(/"/g, "&quot;")   // Escape double quote
                .replace(/'/g, "&#039;");   // Escape single quote
        }

        const rulesDropdownItems = document.getElementById('rulesDropdownItems');

        // Check if there are any rules
        rules = selectedSystem ? systems[selectedSystem]['rules'] : []

        if (rules.length === 0) {
            rulesDropdownItems.innerHTML = '<li class="dropdown-item">No additional rules available</li>';
        } else {
            // Create dropdown items dynamically
            rules.forEach(rule => {
                const listItem = document.createElement('li');
                listItem.className = 'dropdown-item d-flex align-items-center text-nowrap';

                const escapedName = escapeHtml(rule.name);  // Escape the rule name

                listItem.innerHTML = `
                    <input class="form-check-input me-2" type="checkbox" id="rule_${escapedName}" name="rules" value="${escapedName}" style="width: 5px; height: 5px;" checked>
                    <label class="form-check-label mb-1" for="rule_${escapedName}">${escapedName}</label>
                `;

                rulesDropdownItems.appendChild(listItem);
            });
        }

        // Select the multi-select dropdown or checkboxes
        const rulesCheckboxes = document.querySelectorAll('input[name="rules"]');

        // Add change event listener to each checkbox
        rulesCheckboxes.forEach(function (checkbox) {
            checkbox.addEventListener('change', function () {
                updatePlot();
            });
        });

        const modesDropdownItems = document.getElementById('modesDropdownItems');

        // Check if there are any rules
        modes = selectedSystem ? systems[selectedSystem]['modes'] : []

        if (rules.length === 0) {
            modesDropdownItems.innerHTML = '<li class="dropdown-item">No additional rules available</li>';
        } else {
            // Create dropdown items dynamically
            for (const [mode, modeDict] of Object.entries(modes)) {
                const listItem = document.createElement('li');
                listItem.className = 'dropdown-item d-flex align-items-center text-nowrap';

                const escapedName = escapeHtml(mode);  // Escape the rule name

                listItem.innerHTML = `
                    <input class="form-check-input me-2" type="checkbox" id="mode_${escapedName}" name="modes" value="${escapedName}" style="width: 5px; height: 5px;" checked>
                    <label class="form-check-label mb-1" for="mode_${escapedName}">${escapedName}</label>
                `;

                modesDropdownItems.appendChild(listItem);
            }
        }

        // Select the multi-select dropdown or checkboxes
        const modeCheckboxes = document.querySelectorAll('input[name="modes"]');

        // Add change event listener to each checkbox
        modeCheckboxes.forEach(function (checkbox) {
            checkbox.addEventListener('change', function () {
                updatePlot();
            });
        });

        let debounceTimeout;

        function processTextAndSendToBackend(text, system, multiWordTokens, selectedSystem) {
            /**
            * Processes a string of text by splitting it into lines, tokenizing each line,
            * merging word splines, and sending the tokenized results to a backend using AJAX.
            */

            // Split the text into lines
            const lines = text.split('\n');

            // Tokenize each line and merge word splines
            const tokenizedResults = lines.map(line => {
                const tokenizedLine = tokenizeWithMultiWords(line, system, multiWordTokens, false);
                return mergeWordSplines(tokenizedLine);
            });

            // Prepare the data to send to the backend as FormData
            const form = document.getElementById('text-form');
            const formData = new FormData(form);
            formData.append('tokenizedSplines', JSON.stringify(tokenizedResults));

            // Send the results to the backend using AJAX
            $.ajax({
                type: 'POST',
                url: `/generate_splines/${selectedSystem}`,
                data: formData, // Send the FormData object
                processData: false, // Prevent jQuery from processing the data
                contentType: false, // Let the browser set the correct Content-Type
                success: function(response) {
                    // Assuming the server returns the raw SVG markup as part of the response
                    $('#output').html(response.image);
                },
                error: function() {
                    $('#output').html('<p>Error generating plot.</p>');
                }
            });
        }

        function mergeWordSplines(textSplines) {
            /**
            * Merges word splines by concatenating points for each word and adjusting shifts.
            */
            const words = [];

            textSplines.forEach(wordSplines => {
                const currentWord = [];
                let currentShift = [0, 0];

                wordSplines.forEach((glyphSplines, gi) => {
                    glyphSplines.forEach(points => {
                        const shiftedPoints = points.map(point => [...point]); // Clone points

                        if (gi !== 0) {
                            const shiftDelta = glyphSplines[0][0];
                            for (let i = 0; i < shiftedPoints.length; i++) {
                                shiftedPoints[i][0] -= shiftDelta[0];
                                shiftedPoints[i][1] -= shiftDelta[1];
                            }
                        }

                        shiftedPoints.forEach(point => {
                            point[0] += currentShift[0];
                            point[1] += currentShift[1];
                        });

                        currentWord.push(shiftedPoints);
                    });

                    // Update the shift to the last point of the last array in the current glyph
                    currentShift = currentWord[currentWord.length - 1][currentWord[currentWord.length - 1].length - 1];
                });

                words.push(currentWord);
            });

            return words;
        }


        function updatePlot() {
            if (!selectedSystem) {
                $('#output').html('<p>Please select a system first.</p>');
            } else {
                const form = document.getElementById('text-form');
                const formData = new FormData(form);
                const text = formData.get('text');
                const rules = formData.getAll('rules');

                // Process the text and rules
                const [processedText, modifiedPhrasesDict] = processText(text, rules, selectedSystem);

                processTextAndSendToBackend(processedText, systems[selectedSystem], modifiedPhrasesDict, selectedSystem)

                // console.log('tokens:', tokens)

                // // Update the FormData object with the modified values
                // formData.set('text', processedText);
                // formData.set('modifiedPhrasesDict', JSON.stringify(modifiedPhrasesDict));
                // formData.set('system', JSON.stringify(systems[selectedSystem]));

                // $.ajax({
                //     type: 'POST',
                //     url: `/generate_splines/${selectedSystem}`,
                //     data: formData, // Send the FormData object
                //     processData: false, // Prevent jQuery from processing the data
                //     contentType: false, // Let the browser set the correct Content-Type
                //     success: function(response) {
                //         // Assuming the server returns the raw SVG markup as part of the response
                //         $('#output').html(response.image);
                //     },
                //     error: function() {
                //         $('#output').html('<p>Error generating plot.</p>');
                //     }
                // });
            }
        }


        function debounce(func, delay) {
            return function(...args) {
                clearTimeout(debounceTimeout);
                debounceTimeout = setTimeout(() => func.apply(this, args), delay);
            };
        }

        // Debounce the plot update to avoid too many requests
        const debouncedUpdatePlot = debounce(updatePlot, 300);

        // Bind the input event on textarea and change event on checkboxes
        $('#text').on('input', function() {
            debouncedUpdatePlot();
        });

        $('#show_knot_points, #show_dots, #show_baselines, #abbrv_words').on('change', function() {
            updatePlot();  // Call updatePlot immediately when checkboxes are modified
        });

        // Initial plot update
        updatePlot();

        document.getElementById('text').focus();

        function processText(text, appliedRules, system) {
            // Convert text to lowercase
            text = text.toLowerCase();

            // Remove unsupported punctuation
            for (let p of ["'"]) {
                text = text.replaceAll(p, '');
            }
            for (let p of ['/', '\\', '-']) {
                text = text.replaceAll(p, ' ');
            }

            text = addSpacesAroundPunctuation(text);

            // Apply all user-defined rules
            for (let rule of systems[system].rules) {
                if (!appliedRules.includes(rule.name)) continue;

                const regex = new RegExp(rule.regex, 'g');
                text = text.replace(regex, rule.replacement);
            }

            // Also apply the rules to phrases_dict so that it detects the modified phrases
            const modifiedPhrasesDict = {};

            for (let [key, value] of Object.entries(systems[system].phrases)) {
                let modifiedKey = key;

                for (let rule of systems[system].rules) {
                    if (!appliedRules.includes(rule.name)) continue;

                    const regex = new RegExp(rule.regex, 'g');
                    modifiedKey = modifiedKey.replace(regex, rule.replacement);
                }

                modifiedPhrasesDict[modifiedKey] = value;
            }

            return [ text, modifiedPhrasesDict ];
        }

        function addSpacesAroundPunctuation(text) {
            // Define a regex pattern to match punctuation and digits
            const pattern = /([\d!"#$%&'()*+,-./:;<=>?@[\\\]^_`{|}~])/g;

            // Substitute with spaces before and after the matched characters
            const spacedText = text.replace(pattern, ' $1 ');

            // Return the modified text, stripping any extra spaces at the ends
            return spacedText.trim();
        }

        function tokenizeString(word, system) {
            /**
             * Tokenizes a single word using a dictionary of regular expressions and corresponding lists of arrays.
             * The function searches for the tokenization with the fewest possible tokens and prioritizes the largest actual match.
             */
            const regexDict = Object.fromEntries(Object.entries(system.glyphs).slice(17));
            Object.entries(system.modes).forEach(([key, value]) => {
                regexDict[value.pattern] = value.points;
            });

            const regexList = Object.entries(regexDict).map(([pattern, value]) => ({ pattern: new RegExp(pattern), value }));
            const memo = {};

            function compareRegexLengths(tokenizationA, tokenizationB) {
                for (let i = 0; i < Math.min(tokenizationA.length, tokenizationB.length); i++) {
                    if (tokenizationA[i].length !== tokenizationB[i].length) {
                        return tokenizationA[i].length > tokenizationB[i].length;
                    }
                }
                return false;
            }

            function findBestTokenization(start) {
                if (start === word.length) {
                    return { tokens: [], count: 0, longestToken: 0, regexList: [] };
                }

                if (memo[start]) return memo[start];

                let bestTokenization = null;
                let fewestTokens = Infinity;
                let longestTokenLength = 0;
                let regexListForBest = [];

                for (const { pattern, value } of regexList) {
                    const match = word.slice(start).match(pattern);
                    if (match && match.index === 0) {
                        const matchLength = match[0].length;
                        const remaining = findBestTokenization(start + matchLength);

                        const currentLongestToken = Math.max(matchLength, remaining.longestToken);
                        const currentRegexList = [pattern.source, ...remaining.regexList];
                        const candidateTokens = [value, ...remaining.tokens];

                        const candidateTokenCount = 1 + remaining.count;

                        if (candidateTokenCount < fewestTokens ||
                            (candidateTokenCount === fewestTokens && currentLongestToken > longestTokenLength) ||
                            (candidateTokenCount === fewestTokens && currentLongestToken === longestTokenLength && compareRegexLengths(currentRegexList, regexListForBest))) {
                            fewestTokens = candidateTokenCount;
                            longestTokenLength = currentLongestToken;
                            regexListForBest = currentRegexList;
                            bestTokenization = candidateTokens;
                        }
                    }
                }

                memo[start] = { tokens: bestTokenization, count: fewestTokens, longestToken: longestTokenLength, regexList: regexListForBest };
                return memo[start];
            }

            return findBestTokenization(0).tokens;
        }

        function tokenizeWithMultiWords(text, system, multiWordTokens, abbrvWords = false) {
            /**
            * Tokenizes the text by first finding multi-word tokens, then tokenizing the remaining words.
            */

            const regexList = Object.keys(system.glyphs).slice(17);
            regexList.push(...Object.values(system.modes).map((mode) => mode.pattern));

            let multiWordMatches = [];
            let textWithPlaceholders;

            if (abbrvWords) {
                ({ textWithPlaceholders, multiWordMatches } = findMultiWordTokens(text, multiWordTokens));
            } else {
                textWithPlaceholders = text;
            }

            const remainingWords = textWithPlaceholders.split(/\s+/);
            const allTokens = [];

            for (const word of remainingWords) {
                if (word === '§') {
                    allTokens.push([multiWordTokens[multiWordMatches.shift()]]);
                } else {
                    allTokens.push(tokenizeString(word, system));
                }
            }

            return allTokens;
        }

        function findMultiWordTokens(text, multiWordTokens) {
            /**
            * Finds and extracts multi-word tokens from the text.
            */
            const matches = [];
            const escapedTokens = multiWordTokens.map((token) => token.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'));
            const sortedTokens = escapedTokens.sort((a, b) => b.length - a.length);
            const multiWordPattern = new RegExp(`\\b(${sortedTokens.join('|')})\\b`, 'g');

            const newText = text.replace(multiWordPattern, (match) => {
                matches.push(match);
                return '§';
            });

            return { textWithPlaceholders: newText, multiWordMatches: matches };
        }
    });
</script>
{% endblock %}
