{% extends "index.html" %}

{% block title %}
<title>abbrv: write</title>
{% endblock %}

{% block content %}
<form id="text-form" class="d-flex flex-column justify-content-start" style="width: 100%">
    <textarea id="text" name="text" class="form-control mb-3" placeholder="Enter text here..."></textarea>

    <div class="d-flex justify-content-center" style="width: 100%">
        <svg id="output" style="width: 100%;"></svg>
    </div>

    <!-- Dropdown Menu -->
    <div class="d-flex mt-3 flex-row justify-content-between">
        <div class="d-flex flex-row">
            <!-- Options Dropdown -->
            <div class="dropdown me-3">
                <button class="btn btn-primary dropdown-toggle" type="button" id="multiSelectDropdown" data-bs-toggle="dropdown" aria-expanded="false">
                    Options
                </button>
                <ul class="dropdown-menu" aria-labelledby="dropdownMenuButton">
                    <li class="dropdown-item button-container align-items-center">
                        <input type="checkbox" id="abbrv_words" name="abbrv_words" style="max-height: 20px; max-width: 20px; min-width: 20px" checked>
                        <label for="abbrv_words" style="flex: 6;">Use word abbreviations</label>
                    </li>
                    <li class="dropdown-item button-container align-items-center">
                        <input type="checkbox" id="show_baselines" name="show_baselines" style="max-height: 20px; max-width: 20px; min-width: 20px" checked>
                        <label for="show_baselines" style="flex: 6;">Show baselines</label>
                    </li>
                    <li class="dropdown-item button-container align-items-center">
                        <input type="checkbox" id="show_dots" name="show_dots" style="max-height: 20px; max-width: 20px; min-width: 20px">
                        <label for="show_dots" style="flex: 6;">Show dots</label>
                    </li>
                    <li class="dropdown-item button-container align-items-center">
                        <input type="checkbox" id="show_knot_points" name="show_knot_points" style="max-height: 20px; max-width: 20px; min-width: 20px">
                        <label for="show_knot_points" style="flex: 6;">Display knot points</label>
                    </li>
                </ul>
            </div>

            <!-- Multi-Select Dropdown -->
            <div class="dropdown me-3">
                <button class="btn btn-primary dropdown-toggle" type="button" id="modesDropdown" data-bs-toggle="dropdown" aria-expanded="false">
                    Modes
                </button>
                <ul class="dropdown-menu" aria-labelledby="modesDropdown" id="modesDropdownItems">
                    <!-- Dropdown items will be inserted here by JavaScript -->
                </ul>
            </div>

            <!-- Multi-Select Dropdown -->
            <div class="dropdown me-3" id="rulesDropdown">
                <button class="btn btn-primary dropdown-toggle" type="button" id="rulesDropdown" data-bs-toggle="dropdown" aria-expanded="false">
                    Rules
                </button>
                <ul class="dropdown-menu" aria-labelledby="rulesDropdown" id="rulesDropdownItems">
                    <!-- Dropdown items will be inserted here by JavaScript -->
                </ul>
            </div>
        <button id="downloadButton" class="btn btn-primary">
            <i class="bi bi-download"></i>
        </button>
    </div>

</form>
{% endblock %}

{% block scripts %}
<script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
<script>
    $(document).ready(function() {
        // Function to retrieve the checkbox states and set variables accordingly
        function updateOptions() {
            const options = {
                abbrv_words: document.getElementById('abbrv_words').checked,
                show_baselines: document.getElementById('show_baselines').checked,
                show_dots: document.getElementById('show_dots').checked,
                show_knot_points: document.getElementById('show_knot_points').checked
            };

            console.log(options); // For debugging purposes

            // Use the options object as needed in your code
            return options;
        }

        function downloadSVG() {
            const svgElement = document.getElementById('output');

            // Add XML prolog and namespace to the SVG
            const svgData = `
                <?xml version="1.0" encoding="UTF-8" standalone="no"?>
                <!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
                ${svgElement.outerHTML}
            `.trim();

            const blob = new Blob([svgData], { type: 'image/svg+xml;charset=utf-8' });
            const url = URL.createObjectURL(blob);

            const a = document.createElement('a');
            a.href = url;
            a.download = 'generated_splines.svg';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        document.getElementById('downloadButton').addEventListener('click', downloadSVG);

        // Function to escape special characters for HTML
        function escapeHtml(unsafe) {
            return unsafe
                .replace(/&/g, "&amp;")   // Escape ampersand
                .replace(/</g, "&lt;")    // Escape less-than
                .replace(/>/g, "&gt;")     // Escape greater-than
                .replace(/"/g, "&quot;")   // Escape double quote
                .replace(/'/g, "&#039;");   // Escape single quote
        }

        const rulesDropdownItems = document.getElementById('rulesDropdownItems');

        // Check if there are any rules
        rules = selectedSystem ? systems[selectedSystem]['rules'] : []

        if (rules.length === 0) {
            rulesDropdownItems.innerHTML = '<li class="dropdown-item">No additional rules available</li>';
        } else {
            // Create dropdown items dynamically
            rules.forEach(rule => {
                const listItem = document.createElement('li');
                listItem.className = 'dropdown-item d-flex align-items-center text-nowrap';

                const escapedName = escapeHtml(rule.name);  // Escape the rule name

                listItem.innerHTML = `
                    <input class="form-check-input me-2" type="checkbox" id="rule_${escapedName}" name="rules" value="${escapedName}" style="width: 5px; height: 5px;" checked>
                    <label class="form-check-label mb-1" for="rule_${escapedName}">${escapedName}</label>
                `;

                rulesDropdownItems.appendChild(listItem);
            });
        }

        // Select the multi-select dropdown or checkboxes
        const rulesCheckboxes = document.querySelectorAll('input[name="rules"]');

        // Add change event listener to each checkbox
        rulesCheckboxes.forEach(function (checkbox) {
            checkbox.addEventListener('change', function () {
                updatePlot();
            });
        });

        const modesDropdownItems = document.getElementById('modesDropdownItems');

        // Check if there are any rules
        modes = selectedSystem ? systems[selectedSystem]['modes'] : []

        if (rules.length === 0) {
            modesDropdownItems.innerHTML = '<li class="dropdown-item">No additional rules available</li>';
        } else {
            // Create dropdown items dynamically
            for (const [mode, modeDict] of Object.entries(modes)) {
                const listItem = document.createElement('li');
                listItem.className = 'dropdown-item d-flex align-items-center text-nowrap';

                const escapedName = escapeHtml(mode);  // Escape the rule name

                listItem.innerHTML = `
                    <input class="form-check-input me-2" type="checkbox" id="mode_${escapedName}" name="modes" value="${escapedName}" style="width: 5px; height: 5px;" checked>
                    <label class="form-check-label mb-1" for="mode_${escapedName}">${escapedName}</label>
                `;

                modesDropdownItems.appendChild(listItem);
            }
        }

        // Select the multi-select dropdown or checkboxes
        const modeCheckboxes = document.querySelectorAll('input[name="modes"]');

        // Add change event listener to each checkbox
        modeCheckboxes.forEach(function (checkbox) {
            checkbox.addEventListener('change', function () {
                updatePlot();
            });
        });

        let debounceTimeout;

        function processTextAndSendToBackend(text, system, multiWordTokens, selectedSystem) {
            /**
            * Processes a string of text by splitting it into lines, tokenizing each line,
            * merging word splines, and sending the tokenized results to a backend using AJAX.
            */

            // Split the text into lines
            const lines = text.split('\n');

            // Tokenize each line and merge word splines
            const tokenizedResults = lines.map(line => {
                const tokenizedLine = tokenizeWithMultiWords(line, system, multiWordTokens, false);
                return mergeWordSplines(tokenizedLine);
            });

            // // Prepare the data to send to the backend as FormData
            // const form = document.getElementById('text-form');
            // const formData = new FormData(form);
            // formData.append('tokenizedSplines', JSON.stringify(tokenizedResults));

            generateSplines(tokenizedResults)
            // $('#output').html('<p>Error generating plot.</p>');

            // // Send the results to the backend using AJAX
            // $.ajax({
            //     type: 'POST',
            //     url: `/generate_splines/${selectedSystem}`,
            //     data: formData, // Send the FormData object
            //     processData: false, // Prevent jQuery from processing the data
            //     contentType: false, // Let the browser set the correct Content-Type
            //     success: function(response) {
            //         // Assuming the server returns the raw SVG markup as part of the response
            //         $('#output').html(response.image);
            //     },
            //     error: function() {
            //         $('#output').html('<p>Error generating plot.</p>');
            //     }
            // });
        }

        function mergeWordSplines(textSplines) {
            /**
            * Merges word splines by concatenating points for each word and adjusting shifts.
            */
            const words = [];

            textSplines.forEach(wordSplines => {
                const currentWord = [];
                let currentShift = [0, 0];

                wordSplines.forEach((glyphSplines, gi) => {
                    glyphSplines.forEach(points => {
                        const shiftedPoints = points.map(point => [...point]); // Clone points

                        if (gi !== 0) {
                            const shiftDelta = glyphSplines[0][0];
                            for (let i = 0; i < shiftedPoints.length; i++) {
                                shiftedPoints[i][0] -= shiftDelta[0];
                                shiftedPoints[i][1] -= shiftDelta[1];
                            }
                        }

                        shiftedPoints.forEach(point => {
                            point[0] += currentShift[0];
                            point[1] += currentShift[1];
                        });

                        currentWord.push(shiftedPoints);
                    });

                    // Update the shift to the last point of the last array in the current glyph
                    currentShift = currentWord[currentWord.length - 1][currentWord[currentWord.length - 1].length - 1];
                });

                words.push(currentWord);
            });

            return words;
        }

        // function generateSplines(tokenizedSplines) {
        //     /**
        //     * Generates and plots splines for tokenized text. Handles line breaks and adjustments.
        //     * Adjusted for SVG's flipped y-axis.
        //     */

        //     const spaceBetweenWords = 0.2;
        //     const lineSpacing = 0.2;

        //     const showDots = document.getElementById('show_dots').checked;
        //     const showKnots = document.getElementById('show_knot_points').checked;
        //     const showBaselines = document.getElementById('show_baselines').checked;

        //     const svgContainer = document.getElementById('output');
        //     svgContainer.innerHTML = ''; // Clear any existing SVG

        //     let currentVerticalOffset = 0;
        //     let rightMostPoint = 0;
        //     let leftMostPoint = 0;
        //     let lowestPoint = 0;
        //     let highestPoint = 0;
        //     const linePositions = [];

        //     tokenizedSplines.forEach(wordSplines => {
        //         let currentShift = [0, 0];
        //         let lineXPos = 0;
        //         const splinesToPlot = [];

        //         wordSplines.forEach(word => {
        //             word.forEach(points => {
        //                 const shiftedPoints = points.map(([x, y]) => [x, -y]); // Flip y-axis
        //                 const xmin = word[0][0][0]; // First character's first point

        //                 for (let i = 0; i < shiftedPoints.length; i++) {
        //                     shiftedPoints[i][0] -= xmin;
        //                     shiftedPoints[i][0] += currentShift[0];
        //                     shiftedPoints[i][1] += currentShift[1];
        //                 }

        //                 lineXPos = Math.max(lineXPos, shiftedPoints[shiftedPoints.length - 1][0]);
        //                 rightMostPoint = Math.max(rightMostPoint, shiftedPoints[shiftedPoints.length - 1][0]);
        //                 leftMostPoint = Math.min(leftMostPoint, shiftedPoints[0][0]);

        //                 splinesToPlot.push(shiftedPoints);
        //             });

        //             currentShift = [lineXPos + spaceBetweenWords, 0];
        //         });

        //         const highestPointCurrentLine = Math.max(...splinesToPlot.flat().map(([x, y]) => -y)); // Flip y-axis for comparison
        //         const lowestPointCurrentLine = Math.min(...splinesToPlot.flat().map(([x, y]) => -y)); // Flip y-axis for comparison

        //         highestPoint = Math.max(highestPoint, highestPointCurrentLine);
        //         lowestPoint = Math.min(lowestPoint, lowestPointCurrentLine);

        //         currentVerticalOffset += highestPointCurrentLine; // Adjust for SVG coordinate system

        //         splinesToPlot.forEach(points => {
        //             const adjustedPoints = points.map(([x, y]) => [x, y + currentVerticalOffset]);
        //             plotSpline(adjustedPoints, showDots, showKnots);
        //         });

        //         linePositions.push(currentVerticalOffset);
        //         currentVerticalOffset += lowestPointCurrentLine - lineSpacing; // Adjust for spacing
        //     });

        //     if (showBaselines) {
        //         plotBaselines(linePositions.map(pos => -pos), [leftMostPoint - spaceBetweenWords, rightMostPoint + spaceBetweenWords]);
        //     }

        //     finalizePlot(rightMostPoint, -highestPoint, -lowestPoint, lineSpacing); // Flip y for final bounding box
        // }


        function generateSplines(tokenizedSplines) {
            /**
            * Generates and plots splines for tokenized text. Handles line breaks and adjustments.
            */

            const spaceBetweenWords = 0.2;
            const lineSpacing = 0.2;

            const showDots = document.getElementById('show_dots').checked;
            const showKnots = document.getElementById('show_knot_points').checked;
            const showBaselines = document.getElementById('show_baselines').checked;

            const svgContainer = document.getElementById('output');
            svgContainer.innerHTML = ''; // Clear any existing SVG

            let currentVerticalOffset = 0;
            let rightMostPoint = 0;
            let leftMostPoint = 0;
            let lowestPoint = 0;
            let highestPoint = 0;
            const linePositions = [];

            tokenizedSplines.forEach(wordSplines => {
                let currentShift = [0, 0]
                let lineXPos = 0;
                const splinesToPlot = [];

                wordSplines.forEach(word => {
                    word.forEach(points => {
                        const shiftedPoints = points.map(([x, y]) => [x, y]); // Clone points
                        const xmin = word[0][0][0]; // First character's first point

                        for (let i = 0; i < shiftedPoints.length; i++) {
                            shiftedPoints[i][0] -= xmin;
                            shiftedPoints[i][0] += currentShift[0];
                            shiftedPoints[i][1] += currentShift[1];
                        }

                        lineXPos = Math.max(lineXPos, shiftedPoints[shiftedPoints.length - 1][0]);
                        rightMostPoint = Math.max(rightMostPoint, shiftedPoints[shiftedPoints.length - 1][0]);
                        leftMostPoint = Math.min(leftMostPoint, shiftedPoints[0][0]);

                        splinesToPlot.push(shiftedPoints);
                    });

                    currentShift = [lineXPos + spaceBetweenWords, 0];
                });

                const highestPointCurrentLine = Math.max(...splinesToPlot.flat().map(([x, y]) => y));
                const lowestPointCurrentLine = Math.min(...splinesToPlot.flat().map(([x, y]) => y));

                currentVerticalOffset -= highestPointCurrentLine;
                // currentVerticalOffset += lowestPointCurrentLine - lineSpacing;

                highestPoint = Math.max(highestPoint, highestPointCurrentLine + currentVerticalOffset)
                lowestPoint = Math.min(lowestPoint, lowestPointCurrentLine + currentVerticalOffset)

                splinesToPlot.forEach(points => {
                    const adjustedPoints = points.map(([x, y]) => [x, y + currentVerticalOffset]);
                    plotSpline(adjustedPoints, showDots, showKnots);
                });

                linePositions.push(currentVerticalOffset);
                currentVerticalOffset += lowestPointCurrentLine - lineSpacing;
            });

            if (showBaselines) {
                plotBaselines(linePositions, [leftMostPoint - spaceBetweenWords, rightMostPoint + spaceBetweenWords]);
            }

            finalizePlot(leftMostPoint, rightMostPoint, highestPoint, lowestPoint, lineSpacing, spaceBetweenWords);
        }

function plotSpline(points, showDots, showKnots) {
    /**
    * Plots a cubic spline using the given points as knot points on the SVG canvas,
    * generating the spline curve and ensuring all points form a single continuous spline.
    */
    const svg = document.getElementById('output');

    if (points.length >= 2) { // Ensure at least two points to draw a spline
        const t = points.map((_, i) => i / (points.length - 1));

        const interpolate = (t, values) => {
            const n = values.length;
            const a = values.slice();
            const b = new Array(n).fill(0);
            const d = new Array(n).fill(0);
            const h = new Array(n - 1).fill(0).map((_, i) => t[i + 1] - t[i]);

            const alpha = new Array(n - 1).fill(0).map((_, i) => {
                if (i === 0) return 0;
                return (3 / h[i] * (a[i + 1] - a[i]) - 3 / h[i - 1] * (a[i] - a[i - 1]));
            });

            const c = new Array(n).fill(0);
            const l = new Array(n).fill(1);
            const mu = new Array(n).fill(0);
            const z = new Array(n).fill(0);

            for (let i = 1; i < n - 1; i++) {
                l[i] = 2 * (t[i + 1] - t[i - 1]) - h[i - 1] * mu[i - 1];
                mu[i] = h[i] / l[i];
                z[i] = (alpha[i] - h[i - 1] * z[i - 1]) / l[i];
            }

            for (let j = n - 2; j >= 0; j--) {
                c[j] = z[j] - mu[j] * c[j + 1];
                b[j] = (a[j + 1] - a[j]) / h[j] - h[j] * (c[j + 1] + 2 * c[j]) / 3;
                d[j] = (c[j + 1] - c[j]) / (3 * h[j]);
            }

            return { a, b, c, d, t };
        };

        const splinePoints = (coeffs, numPoints) => {
            const { a, b, c, d, t } = coeffs;
            const result = [];

            for (let i = 0; i < t.length - 1; i++) {
                const step = (t[i + 1] - t[i]) / numPoints;
                for (let j = 0; j <= numPoints; j++) {
                    const x = t[i] + j * step;
                    const dx = x - t[i];
                    const value = a[i] + b[i] * dx + c[i] * dx ** 2 + d[i] * dx ** 3;
                    result.push(value);
                }
            }

            return result;
        };

        const x = points.map(p => p[0]);
        const y = points.map(p => p[1]);

        const xCoeffs = interpolate(t, x);
        const yCoeffs = interpolate(t, y);

        const xDense = splinePoints(xCoeffs, 20);
        const yDense = splinePoints(yCoeffs, 20);

        let d = `M ${xDense[0]} ${yDense[0]}`;
        for (let i = 1; i < xDense.length; i++) {
            d += ` L ${xDense[i]} ${yDense[i]}`;
        }

        const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        path.setAttribute('d', d);
        path.setAttribute('fill', 'none');
        path.setAttribute('stroke', 'black');
        path.setAttribute('stroke-width', '0.01');
        path.setAttribute('stroke-linecap', 'round'); // Set rounded line caps
        svg.appendChild(path);
    }

    // Optionally show dots at points
    if (showDots) {
        points.forEach(([x, y]) => {
            const dot = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            dot.setAttribute('cx', x);
            dot.setAttribute('cy', y);
            dot.setAttribute('r', 2);
            dot.setAttribute('fill', 'red');
            svg.appendChild(dot);
        });
    }

    // Optionally show knots as blue squares
    if (showKnots) {
        points.forEach(([x, y]) => {
            const knot = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            knot.setAttribute('x', x - 1);
            knot.setAttribute('y', y - 1);
            knot.setAttribute('width', 2);
            knot.setAttribute('height', 2);
            knot.setAttribute('fill', 'blue');
            svg.appendChild(knot);
        });
    }
}


        function plotBaselines(positions, xlims) {
            /**
            * Plots baselines for the lines.
            */
            const svg = document.getElementById('output');
            positions.forEach(y => {
                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line.setAttribute('x1', xlims[0]);
                line.setAttribute('x2', xlims[1]);
                line.setAttribute('y1', y);
                line.setAttribute('y2', y);
                line.setAttribute('stroke', 'grey');
                line.setAttribute('stroke-dasharray', '0.02, 0.02');
                line.setAttribute('stroke-width', '0.005');

                // Prepend the line to the SVG element to ensure it is below other elements
                svg.insertBefore(line, svg.firstChild);
            });
        }

        function finalizePlot(leftMostPoint, rightMostPoint, highestPoint, lowestPoint, lineSpacing, spaceBetweenWords) {
            const svg = document.getElementById('output');
            svg.setAttribute('viewBox', `${leftMostPoint - 2 * spaceBetweenWords} -${Math.abs(lowestPoint - lineSpacing)} ${rightMostPoint + 4 * spaceBetweenWords} ${highestPoint - lowestPoint + 2 * lineSpacing}`); // Normalize viewBox
            // svg.setAttribute('viewBox', `0 ${highestPoint - lineSpacing} ${rightMostPoint} ${Math.abs(highestPoint - lowestPoint) + 2 * lineSpacing}`); // Normalize viewBox
            svg.setAttribute('preserveAspectRatio', 'xMidYMid meet'); // Scale uniformly
            // Get the height of the SVG
            const svgHeight = svg.getAttribute('height') || svg.viewBox.baseVal.height;

            // Apply the transformation
            svg.setAttribute('transform', `scale(1, -1) translate(0, -${svgHeight})`);
        }

        function updatePlot() {
            if (!selectedSystem) {
                $('#output').html('<p>Please select a system first.</p>');
            } else {
                const form = document.getElementById('text-form');
                const formData = new FormData(form);
                const text = formData.get('text');
                const rules = formData.getAll('rules');

                // Process the text and rules
                const [processedText, modifiedPhrasesDict] = processText(text, rules, selectedSystem);

                processTextAndSendToBackend(processedText, systems[selectedSystem], modifiedPhrasesDict, selectedSystem)

                // console.log('tokens:', tokens)

                // // Update the FormData object with the modified values
                // formData.set('text', processedText);
                // formData.set('modifiedPhrasesDict', JSON.stringify(modifiedPhrasesDict));
                // formData.set('system', JSON.stringify(systems[selectedSystem]));

                // $.ajax({
                //     type: 'POST',
                //     url: `/generate_splines/${selectedSystem}`,
                //     data: formData, // Send the FormData object
                //     processData: false, // Prevent jQuery from processing the data
                //     contentType: false, // Let the browser set the correct Content-Type
                //     success: function(response) {
                //         // Assuming the server returns the raw SVG markup as part of the response
                //         $('#output').html(response.image);
                //     },
                //     error: function() {
                //         $('#output').html('<p>Error generating plot.</p>');
                //     }
                // });
            }
        }


        function debounce(func, delay) {
            return function(...args) {
                clearTimeout(debounceTimeout);
                debounceTimeout = setTimeout(() => func.apply(this, args), delay);
            };
        }

        // Debounce the plot update to avoid too many requests
        const debouncedUpdatePlot = debounce(updatePlot, 300);

        // Bind the input event on textarea and change event on checkboxes
        $('#text').on('input', function() {
            debouncedUpdatePlot();
        });

        $('#show_knot_points, #show_dots, #show_baselines, #abbrv_words').on('change', function() {
            updatePlot();  // Call updatePlot immediately when checkboxes are modified
        });

        // Initial plot update
        updatePlot();

        document.getElementById('text').focus();

        function processText(text, appliedRules, system) {
            // Convert text to lowercase
            text = text.toLowerCase();

            // Remove unsupported punctuation
            for (let p of ["'"]) {
                text = text.replaceAll(p, '');
            }
            for (let p of ['/', '\\', '-']) {
                text = text.replaceAll(p, ' ');
            }

            text = addSpacesAroundPunctuation(text);

            // Apply all user-defined rules
            for (let rule of systems[system].rules) {
                if (!appliedRules.includes(rule.name)) continue;

                const regex = new RegExp(rule.regex, 'g');
                text = text.replace(regex, rule.replacement);
            }

            // Also apply the rules to phrases_dict so that it detects the modified phrases
            const modifiedPhrasesDict = {};

            for (let [key, value] of Object.entries(systems[system].phrases)) {
                let modifiedKey = key;

                for (let rule of systems[system].rules) {
                    if (!appliedRules.includes(rule.name)) continue;

                    const regex = new RegExp(rule.regex, 'g');
                    modifiedKey = modifiedKey.replace(regex, rule.replacement);
                }

                modifiedPhrasesDict[modifiedKey] = value;
            }

            return [ text, modifiedPhrasesDict ];
        }

        function addSpacesAroundPunctuation(text) {
            // Define a regex pattern to match punctuation and digits
            const pattern = /([\d!"#$%&'()*+,-./:;<=>?@[\\\]^_`{|}~])/g;

            // Substitute with spaces before and after the matched characters
            const spacedText = text.replace(pattern, ' $1 ');

            // Return the modified text, stripping any extra spaces at the ends
            return spacedText.trim();
        }

        function tokenizeString(word, system) {
            /**
             * Tokenizes a single word using a dictionary of regular expressions and corresponding lists of arrays.
             * The function searches for the tokenization with the fewest possible tokens and prioritizes the largest actual match.
             */
            const regexDict = Object.fromEntries(Object.entries(system.glyphs).slice(17));
            Object.entries(system.modes).forEach(([key, value]) => {
                regexDict[value.pattern] = value.points;
            });

            const regexList = Object.entries(regexDict).map(([pattern, value]) => ({ pattern: new RegExp(pattern), value }));
            const memo = {};

            function compareRegexLengths(tokenizationA, tokenizationB) {
                for (let i = 0; i < Math.min(tokenizationA.length, tokenizationB.length); i++) {
                    if (tokenizationA[i].length !== tokenizationB[i].length) {
                        return tokenizationA[i].length > tokenizationB[i].length;
                    }
                }
                return false;
            }

            function findBestTokenization(start) {
                if (start === word.length) {
                    return { tokens: [], count: 0, longestToken: 0, regexList: [] };
                }

                if (memo[start]) return memo[start];

                let bestTokenization = null;
                let fewestTokens = Infinity;
                let longestTokenLength = 0;
                let regexListForBest = [];

                for (const { pattern, value } of regexList) {
                    const match = word.slice(start).match(pattern);
                    if (match && match.index === 0) {
                        const matchLength = match[0].length;
                        const remaining = findBestTokenization(start + matchLength);

                        const currentLongestToken = Math.max(matchLength, remaining.longestToken);
                        const currentRegexList = [pattern.source, ...remaining.regexList];
                        const candidateTokens = [value, ...remaining.tokens];

                        const candidateTokenCount = 1 + remaining.count;

                        if (candidateTokenCount < fewestTokens ||
                            (candidateTokenCount === fewestTokens && currentLongestToken > longestTokenLength) ||
                            (candidateTokenCount === fewestTokens && currentLongestToken === longestTokenLength && compareRegexLengths(currentRegexList, regexListForBest))) {
                            fewestTokens = candidateTokenCount;
                            longestTokenLength = currentLongestToken;
                            regexListForBest = currentRegexList;
                            bestTokenization = candidateTokens;
                        }
                    }
                }

                memo[start] = { tokens: bestTokenization, count: fewestTokens, longestToken: longestTokenLength, regexList: regexListForBest };
                return memo[start];
            }

            return findBestTokenization(0).tokens;
        }

        function tokenizeWithMultiWords(text, system, multiWordTokens, abbrvWords = false) {
            /**
            * Tokenizes the text by first finding multi-word tokens, then tokenizing the remaining words.
            */

            const regexList = Object.keys(system.glyphs).slice(17);
            regexList.push(...Object.values(system.modes).map((mode) => mode.pattern));

            let multiWordMatches = [];
            let textWithPlaceholders;

            if (abbrvWords) {
                ({ textWithPlaceholders, multiWordMatches } = findMultiWordTokens(text, multiWordTokens));
            } else {
                textWithPlaceholders = text;
            }

            const remainingWords = textWithPlaceholders.split(/\s+/);
            const allTokens = [];

            for (const word of remainingWords) {
                if (word === '§') {
                    allTokens.push([multiWordTokens[multiWordMatches.shift()]]);
                } else {
                    allTokens.push(tokenizeString(word, system));
                }
            }

            return allTokens;
        }

        function findMultiWordTokens(text, multiWordTokens) {
            /**
            * Finds and extracts multi-word tokens from the text.
            */
            const matches = [];
            const escapedTokens = multiWordTokens.map((token) => token.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'));
            const sortedTokens = escapedTokens.sort((a, b) => b.length - a.length);
            const multiWordPattern = new RegExp(`\\b(${sortedTokens.join('|')})\\b`, 'g');

            console.log('mwp', multiWordPattern)

            const newText = text.replace(multiWordPattern, (match) => {
                console.log('match', match)
                matches.push(match);
                return '§';
            });

            return { textWithPlaceholders: newText, multiWordMatches: matches };
        }
    });
</script>
{% endblock %}
